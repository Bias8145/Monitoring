<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#4CAF50">
    <title>Sistem Checklist Air</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Poppins:wght@500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <!-- Libraries for exporting the meter sheet to PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Additional libraries for Excel export and PDF import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.10.111/pdf.min.js"></script>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: 'Poppins', 'Roboto', sans-serif;
    overflow-x: hidden;
    /* Smooth transition when switching themes */
    transition: background 0.5s ease, color 0.5s ease;
}
body, input, select, textarea, button, table, th, td {
    font-family: 'Poppins', 'Roboto', sans-serif !important;
}
body.light-theme {
    background: linear-gradient(135deg, #f5f7fa, #c3cfe2);
    color: #333;
}
body.dark-theme {
    background: linear-gradient(135deg, #1e1e2f, #2a2a4a);
    color: #e0e0e0;
}
body.light-theme .container,
body.light-theme .login-card,
body.light-theme .modal {
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
}
body.dark-theme .container,
body.dark-theme .login-card,
body.dark-theme .modal {
    background: rgba(30, 30, 46, 0.85);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
}
body.light-theme .card {
    background: rgba(245, 245, 245, 0.9);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}
body.dark-theme .card {
    background: rgba(40, 40, 60, 0.9);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}
body.light-theme .header {
    background: linear-gradient(135deg, #ffffff, #e0e0e0);
    color: #333;
}
body.dark-theme .header {
    background: linear-gradient(135deg, #2e2e4a, #3a3a5a);
    color: #e0e0e0;
}
body.light-theme .form-group select,
body.light-theme .form-group input,
body.light-theme .form-group textarea,
body.light-theme .login-card input {
    background: rgba(220, 220, 220, 0.85);
    color: #333;
}
body.dark-theme .form-group select,
body.dark-theme .form-group input,
body.dark-theme .form-group textarea,
body.dark-theme .login-card input {
    background: rgba(50, 50, 70, 0.85);
    color: #e0e0e0;
    font-size: 13px;
}
body.light-theme .unit {
    background: rgba(76, 175, 80, 0.3);
    color: #333;
}
body.dark-theme .unit {
    background: rgba(76, 175, 80, 0.2);
    color: #e0e0e0;
}
body.light-theme .switch-type {
    background: rgba(220, 220, 220, 0.9);
}
body.dark-theme .switch-type {
    background: rgba(40, 40, 60, 0.9);
}
body.light-theme .switch-btn {
    color: #333;
}
body.dark-theme .switch-btn {
    color: #e0e0e0;
}
body.light-theme table {
    background: rgba(245, 245, 245, 0.9);
}
body.dark-theme table {
    background: rgba(40, 40, 60, 0.9);
}
body.light-theme th {
    background: rgba(230, 230, 230, 0.95);
    font-size: 12px;
}
/* ----------------------------------------------------------------
 * Custom enhancements for glassmorphism and new dashboard elements
 * These styles introduce glass-like summary cards on the attendance
 * dashboard, hero animations on the landing and login pages, and
 * education cards for offline use.  They adapt to both light and
 * dark themes by applying semi‑transparent backgrounds and soft
 * shadows.  Additional classes control the sizing of lottie
 * animation containers used throughout the site.
 */
/* Dashboard summary cards (attendance page) */
.dashboard-summary-cards {
    display: flex;
    gap: 12px;
    margin: 15px;
    flex-wrap: wrap;
}
.summary-card {
    flex: 1 1 calc(33.333% - 12px);
    padding: 15px;
    border-radius: 12px;
    text-align: center;
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
}
body.light-theme .summary-card {
    background: rgba(255, 255, 255, 0.8);
    color: #333;
}
body.dark-theme .summary-card {
    background: rgba(40, 40, 60, 0.8);
    color: #e0e0e0;
}
.summary-card i {
    font-size: 24px;
    margin-bottom: 6px;
    color: #4CAF50;
}
.summary-title {
    font-size: 14px;
    font-weight: 600;
    margin-bottom: 4px;
}
.summary-value {
    font-size: 22px;
    font-weight: 700;
}
/* Lottie animation sizing for landing, login and analysis */
.landing-animation {
    width: 220px;
    height: 220px;
    margin: 0 auto 20px auto;
}
.login-animation {
    width: 80px;
    height: 80px;
    margin-right: 12px;
}
.analysis-animation {
    width: 120px;
    height: 120px;
    margin: 0 auto 12px auto;
}
/* Education grid and cards for offline content */
.education-grid {
    display: grid;
    gap: 12px;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    margin-top: 10px;
}
.education-card {
    padding: 12px;
    border-radius: 10px;
    backdrop-filter: blur(8px);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    position: relative;
}
body.light-theme .education-card {
    background: rgba(255, 255, 255, 0.8);
    color: #333;
}
body.dark-theme .education-card {
    background: rgba(40, 40, 60, 0.8);
    color: #e0e0e0;
}
.education-card h4 {
    margin-bottom: 6px;
    font-size: 14px;
    font-weight: 600;
}
.education-card p {
    font-size: 12px;
    margin-bottom: 8px;
}
.education-category {
    font-size: 11px;
    font-weight: 600;
    color: #4CAF50;
    position: absolute;
    bottom: 8px;
    right: 12px;
}
body.dark-theme th {
    background: rgba(50, 50, 70, 0.95);
    font-size: 12px;
}
body.light-theme td,
body.dark-theme td {
    font-size: 12px;
}
body.light-theme .nav-bar {
    /* Apply soft green gradient for light theme nav bar and remove border */
    background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
    /* Smooth color transition for theme switching */
    transition: background 0.5s ease, color 0.5s ease;
}
body.dark-theme .nav-bar {
    /* Apply dark blue gradient for dark theme nav bar and remove border */
    background: linear-gradient(135deg, #37474f, #263238);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
    transition: background 0.5s ease, color 0.5s ease;
}
body.light-theme .nav-item {
    color: #fff;
}
body.dark-theme .nav-item {
    color: #fff;
}
body.light-theme .nav-item:hover {
    background: rgba(76, 175, 80, 0.15);
    transform: translateY(-2px);
}
body.dark-theme .nav-item:hover {
    background: rgba(76, 175, 80, 0.35);
    transform: translateY(-2px);
}
.container {
    max-width: 600px;
    width: 100%;
    border-radius: 20px;
    backdrop-filter: blur(12px);
    overflow: hidden;
    position: relative;
    z-index: 1;
    padding-bottom: 100px;
    margin-top: 20px !important;
    padding-top: 0 !important;
    /* Add subtle drop shadow */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    transition: box-shadow 0.3s ease;
}
.card {
    border-radius: 16px;
    padding: 20px;
    margin: 15px;
    /* Remove heavy 3D transform in favour of subtle elevation */
    transform: none;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}
/*
 * Override the 3D transform on analysis cards.  The default `.card` style
 * applies a perspective and rotation effect which looks attractive for
 * static content but causes `<canvas>` elements used for charts to become
 * skewed and stretched.  To ensure charts retain their proper aspect
 * ratio, we remove the transform and transition for cards inside the
 * analysis container.
 */
#analysisContent .card {
    transform: none;
    transition: none;
}
#analysisContent .card:hover {
    transform: none;
}
.card:hover {
    /* Subtle lift on hover */
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
}
.header {
    padding: 15px 20px !important;
    text-align: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 20px 20px 0 0;
    position: relative;
    /* Remove 3D translation to maintain flat design */
    transform: none;
    margin-bottom: 10px !important;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    transition: box-shadow 0.3s ease;
}
.header h1 {
    font-weight: 700;
    font-size: 22px;
    margin-bottom: 8px;
}
.header .greeting {
    font-size: 18px;
    font-weight: 500;
    margin-bottom: 8px;
}
.header .subtitle {
    font-size: 14px;
    opacity: 0.7;
}
.form-group {
    margin-bottom: 20px;
    position: relative;
    /* Remove 3D translation */
    transform: none;
}
.form-group select,
.form-group input,
.form-group textarea {
    width: 100%;
    padding: 12px;
    border: none;
    border-radius: 12px;
    font-size: 13px;
    transition: background 0.3s ease, box-shadow 0.3s ease;
}
.form-group textarea {
    resize: vertical;
    min-height: 100px;
}
.form-group select:focus,
.form-group input:focus,
.form-group textarea:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.3);
    box-shadow: 0 0 8px rgba(76,175,80,0.5);
}
.input-group {
    display: flex;
    gap: 10px;
    align-items: center;
}
.unit {
    padding: 12px;
    border-radius: 12px;
    min-width: 50px;
    text-align: center;
    font-size: 13px;
}
.section-divider {
    height: 2px;
    background: linear-gradient(90deg, #4CAF50, #81C784);
    margin: 20px 0;
    border-radius: 2px;
    /* Flatten divider */
    transform: none;
}
.switch-type {
    display: flex;
    gap: 10px;
    border-radius: 12px;
    padding: 8px;
    margin-bottom: 20px;
    transform: none;
    transition: background-color 0.3s ease;
}
.switch-btn {
    flex: 1;
    padding: 12px;
    text-align: center;
    border: none;
    border-radius: 10px;
    background: none;
    cursor: pointer;
    font-weight: 500;
    font-size: 13px;
    transition: all 0.3s ease;
}
.switch-btn.active {
    background: #4CAF50;
    color: white;
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
}

/*
 * Custom file input labels for capturing and uploading damage photos.  The
 * underlying <input type="file"> elements are hidden, and these labels
 * provide a stylised interface with FontAwesome icons.  The styles
 * differentiate between light and dark themes and include hover effects.
 */
.file-input-label {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    border-radius: 12px;
    cursor: pointer;
    font-weight: 500;
    font-size: 13px;
    transition: background 0.3s ease, color 0.3s ease;
    border: 2px dashed rgba(0, 0, 0, 0.2);
}
.file-input-label i {
    font-size: 16px;
}
body.light-theme .file-input-label {
    background: rgba(245, 245, 245, 0.9);
    color: #333;
    border-color: rgba(0, 0, 0, 0.15);
}
body.dark-theme .file-input-label {
    background: rgba(60, 60, 80, 0.9);
    color: #e0e0e0;
    border-color: rgba(255, 255, 255, 0.2);
}
.file-input-label:hover {
    background: rgba(76, 175, 80, 0.15);
}
.btn {
    width: 100%;
    padding: 14px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    transition: all 0.3s ease;
    transform: perspective(1000px) translateZ(10px);
    position: relative;
}
.btn:hover {
    transform: perspective(1000px) translateZ(20px);
    box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
    transform: translateY(-2px);
    box-shadow: 0 8px 18px rgba(76,175,80,0.4);
}
.btn.loading {
    pointer-events: none;
    cursor: not-allowed;
}
.btn.loading {
    position: relative;
    pointer-events: none;
    cursor: not-allowed;
    padding-right: 44px; /* ruang untuk spinner di kanan */
}
.btn.loading::after {
    content: "";
    position: absolute;
    right: 16px;
    top: 50%;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,0.3);
    border-top-color: #fff;
    border-radius: 50%;
    transform: translateY(-50%);
    animation: btnSpin 1s linear infinite;
}
@keyframes btnSpin {
    to { transform: translateY(-50%) rotate(360deg); }
}
.btn.loading i { display: none; }
.btn.loading .btn-text {
    margin-left: 24px;
}
.btn.loading i {
    display: none;
}
.table-container {
    max-height: 300px;
    overflow-y: auto;
    overflow-x: auto; /* allow horizontal scrolling for wide tables */
    margin: 15px 0;
    border-radius: 12px;
    transform: perspective(1000px) translateZ(5px);
}
table {
    width: 100%;
    border-collapse: collapse;
    border-radius: 12px;
    overflow: hidden;
}
th, td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
th {
    position: sticky;
    top: 0;
    font-weight: 600;
}
td button {
    padding: 8px 12px;
    border: none;
    border-radius: 10px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.3s ease;
    transform: perspective(1000px) translateZ(5px);
}
td button:hover {
    background: #45a049;
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    transform: perspective(1000px) translateZ(10px);
}
td button.whatsapp-btn {
    background: #25D366;
}
td button.whatsapp-btn:hover {
    background: #20B058;
    box-shadow: 0 4px 12px rgba(37, 211, 102, 0.4);
}
td button.edit-btn {
    background: #FFC107;
    color: #333;
}
td button.edit-btn:hover {
    background: #FFB300;
    box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
}
td button.edit-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
}

/* Custom styles for damage report action buttons */
td button.preview-btn {
    background: #03A9F4;
    color: white;
}
td button.preview-btn:hover {
    background: #0288D1;
    box-shadow: 0 4px 12px rgba(3, 169, 244, 0.4);
}
td button.edit-damage-btn {
    background: #FFC107;
    color: #333;
}
td button.edit-damage-btn:hover {
    background: #FFB300;
    box-shadow: 0 4px 12px rgba(255, 193, 7, 0.4);
}

/* === Custom styles for meter block tabs === */
/* Container for block tabs above the meter sheet. Displays blocks horizontally and wraps on small screens. */
/*
 * Styling for the block tabs used on the meter sheet.  These tabs are designed
 * to resemble browser tabs: they align horizontally with no gaps, have
 * rounded top corners, and share a bottom border with the container.  The
 * active tab is highlighted with the primary theme colour.
 */
.block-tabs {
    display: flex;
    flex-wrap: wrap;
    gap: 0;
    margin-bottom: 12px;
    align-items: flex-end;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
}
body.dark-theme .block-tabs {
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
}
.block-tab {
    padding: 10px 16px;
    border: 1px solid transparent;
    border-bottom: none;
    border-radius: 12px 12px 0 0;
    margin-right: 4px;
    cursor: pointer;
    font-size: 13px;
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    user-select: none;
}
body.light-theme .block-tab {
    background: rgba(230, 230, 230, 0.9);
    color: #333;
}
body.dark-theme .block-tab {
    background: rgba(60, 60, 80, 0.85);
    color: #e0e0e0;
}
.block-tab.active {
    background: #4CAF50;
    color: #fff;
    border-color: #4CAF50;
    box-shadow: none;
}
body.dark-theme .block-tab.active {
    background: #4CAF50;
    color: #fff;
    border-color: #4CAF50;
}

/* --- Meter sheet layout overrides --- */
/* Position the block tabs in a single horizontal row above the table and allow
   the user to scroll horizontally to access additional blocks. These rules
   override earlier definitions of .block-tabs and .block-tab. */
.block-tabs {
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
}
.block-tabs .block-tab {
    /* Prevent flexbox from shrinking the tab widths; each tab keeps its
       intrinsic width and the container can scroll horizontally */
    flex: 0 0 auto;
}

/*
 * Add borders to the meter sheet table for better readability.  Each cell is
 * delineated with a subtle border that adapts to the light and dark themes.
 */
#sheetTable {
    border-collapse: collapse;
}
#sheetTable th,
#sheetTable td {
    border: 1px solid rgba(0, 0, 0, 0.2);
}
body.dark-theme #sheetTable th,
body.dark-theme #sheetTable td {
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/*
 * Improve the meter sheet usability by freezing the header row and the first
 * column.  Without sticky headers and columns, it’s easy to lose context when
 * scrolling a wide table horizontally or vertically.  Setting `position:
 * sticky` on `<th>` elements makes the header row stay at the top as the user
 * scrolls down the table【430569600632284†L120-L126】, while making the first
 * cell in each row sticky keeps the date column visible when scrolling
 * horizontally【446093273901204†L159-L170】.  Different background colours and
 * z‑index values ensure sticky cells sit above the rest of the table and do
 * not bleed through other content【195241354059849†L49-L61】.
 */
#sheetTable th {
    position: sticky;
    top: 0;
    z-index: 2;
    /* Use a subtle background so headers remain legible in both themes */
    background: rgba(245, 245, 245, 0.95);
}
body.dark-theme #sheetTable th {
    background: rgba(60, 60, 80, 0.95);
}
/* Make the top‑left cell (header for the date column) sit above other sticky
 * elements by increasing its z‑index and anchoring it to the left */
#sheetTable th:first-child {
    left: 0;
    z-index: 3;
}
#sheetTable td:first-child {
    position: sticky;
    left: 0;
    z-index: 1;
    background: rgba(245, 245, 245, 0.95);
}
body.dark-theme #sheetTable td:first-child {
    background: rgba(60, 60, 80, 0.95);
}
.filter-group {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
    transform: perspective(1000px) translateZ(5px);
}
.filter-group select {
    flex: 1;
    min-width: 120px;
    padding: 12px;
    border-radius: 12px;
    font-size: 13px;
}

/* Layout overrides for the meter sheet controls on the meter page.  These styles
 * arrange the period selector and action buttons horizontally at the top of
 * the sheet card.  Elements wrap responsively on narrow screens. */
.sheet-controls {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    align-items: center;
    gap: 10px;
    margin-bottom: 20px;
    transform: perspective(1000px) translateZ(5px);
}
.sheet-button-group {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
}
.sheet-date-group {
    display: flex;
}
/* Ensure the month input expands to fill the available space within its row */
.sheet-date-group input[type="month"] {
    flex: 1;
}
/* Override button sizing within the sheet button group so they do not stretch
   to fill the full width of their container.  Allow them to distribute
   evenly while maintaining responsive behaviour on narrow screens. */
.sheet-button-group .btn {
    width: auto;
    flex: 1 1 auto;
    min-width: 110px;
}

/* Label preceding the period picker in the sheet controls */
.sheet-label {
    font-weight: 500;
    margin-right: 4px;
    font-size: 13px;
}

/* Hide the old "Tampilkan" button; the sheet loads automatically based on the selected period */
#sheetLoadButton {
    display: none !important;
}

/* === Additional styles for the dedicated attendance page and button === */
/* Attendance toggle button placed next to the theme toggle */
.attendance-toggle {
    position: absolute;
    top: 20px;
    left: 72px;
    width: 44px;
    height: 44px;
    border-radius: 12px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.25s ease;
    font-size: 16px;
    background: rgba(224, 224, 224, 0.1);
    color: #4CAF50;
    z-index: 9999; /* ensure it appears above other elements */
    /* When testing, we applied a visible border; remove for final version */
    border: none;
}
.attendance-toggle:hover {
    background: rgba(224, 224, 224, 0.15);
    transform: translateY(-1px);
}
body.light-theme .attendance-toggle {
    background: rgba(100, 100, 100, 0.1);
}
@media (max-width: 600px) {
    .attendance-toggle {
        width: 40px;
        height: 40px;
        font-size: 14px;
        left: 66px;
        top: 20px;
    }
}
/* Staff list styles */
.staff-list {
    list-style: none;
    padding-left: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    gap: 6px;
}
.staff-list li {
    /* Display list items as block containers.  The first row (staff-row)
       handles horizontal alignment of the name and badges, while any
       additional information is stacked below.  Using block instead of
       flex here ensures expandable details appear beneath the main row
       rather than squeezed alongside it. */
    display: block;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 13px;
}

/* Make the attendance count badges push to the far right of the staff
   list item.  When combined with flexbox on the list item, this
   automatically aligns the badges consistently and avoids irregular
   spacing. */
.staff-list .attendance-count {
    /* The attendance-count container sits in the staff-row to the right of
       the staff name.  It remains inline‑flex for proper spacing of
       badges. */
    margin-left: auto;
    display: inline-flex;
    gap: 4px;
    align-items: center;
}

/* Container for the primary row within each staff item.  This row uses
   flexbox to align the coloured dot, name, NIK tag and badge group
   horizontally.  Additional details are displayed in a separate block
   underneath. */
.staff-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* Small coloured dot indicating the assigned colour for each staff
   member.  Users can click this dot (or anywhere in the row) to
   reveal additional information about that staff member. */
.staff-color-dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
    flex-shrink: 0;
}

/* Hidden details panel for each staff entry.  When the user clicks
   on the staff item, this panel toggles between hidden and visible
   states, revealing further metrics (late, early and checklist
   counts). */
.staff-details {
    display: none;
    font-size: 12px;
    margin-top: 4px;
    line-height: 1.3;
    opacity: 0.85;
}
body.light-theme .staff-list li {
    background: rgba(76, 175, 80, 0.1);
    color: #333;
}
body.dark-theme .staff-list li {
    background: rgba(60, 60, 80, 0.8);
    color: #e0e0e0;
}
/* Freeze the second header row in the meter sheet so column labels stay visible while scrolling */
#sheetTable thead tr:nth-child(1) th {
    position: sticky;
    top: 0;
    z-index: 4;
}
#sheetTable thead tr:nth-child(2) th {
    position: sticky;
    top: 32px; /* approximate height of the first header row */
    z-index: 3;
}
.login-container {
    max-width: 400px;
    width: 100%;
    text-align: center;
    position: relative;
    z-index: 1;
    margin-top: 100px !important;
}
.login-card .subtitle {
    font-size: 16px;
    opacity: 0.7;
    margin-bottom: 20px;
}
.login-card input {
    width: 100%;
    padding: 12px;
    margin: 10px 0;
    border: none;
    border-radius: 12px;
    font-size: 13px;
    transform: perspective(1000px) translateZ(5px);
}
.dark-theme .login-input-card {
    background: rgba(50, 50, 70, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.05);
}
.light-theme .login-input-card {
    background: rgba(240, 240, 240, 0.8);
    border: 1px solid rgba(0, 0, 0, 0.05);
}
.login-input-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
}
.input-wrapper {
    position: relative;
    margin-bottom: 20px;
}
.input-icon {
    position: absolute;
    left: 18px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 16px;
    z-index: 2;
    transition: all 0.3s ease;
    color: rgba(255,255,255,0.5);
}
body.light-theme .input-icon {
    color: rgba(0, 0, 0, 0.5);
}
.input-wrapper input:focus {
    border: 2px solid #4CAF50;
    box-shadow: 0 0 10px rgba(76,175,80,0.3);
}
.input-wrapper input:focus + .input-icon {
    color: #4CAF50;
    transform: translateY(-50%) scale(1.05);
}
.login-header-icon {
    font-size: 48px;
    color: #4CAF50;
    margin-bottom: 15px;
    animation: popIn 0.6s ease;
}
.login-footer {
    margin-top: 30px;
    font-size: 13px;
    opacity: 0.7;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}
.horizontal-logo {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 16px;
    margin-bottom: 35px;
    flex-wrap: wrap;
}
.logo-icon-inline {
    width: 56px;
    height: 56px;
    border-radius: 16px;
    background: linear-gradient(135deg, #4CAF50, #45a049);
    box-shadow: 0 8px 24px rgba(76, 175, 80, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    animation: logoFloat 3s ease-in-out infinite;
}
.logo-icon-inline i {
    font-size: 24px;
    color: white;
}
.logo-text .subtitle {
    font-size: 13px;
    opacity: 0.7;
    font-weight: 400;
    text-align: left;
    color: inherit;
}
.logo-section.horizontal-logo {
    margin-bottom: 20px;
    text-align: left !important;
}
.notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(244, 67, 54, 0.9);
    color: white;
    padding: 15px 20px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    display: none;
    font-size: 14px;
    transform: perspective(1000px) translateZ(10px);
    z-index: 1000;
}
.notification.success {
    background: rgba(76, 175, 80, 0.9);
}
.nav-bar {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    max-width: 600px;
    width: 90%;
    display: flex;
    justify-content: space-around;
    padding: 14px 20px;
    border-radius: 20px;
    z-index: 1000;
    transition: all 0.3s ease;
    /* unify nav bar style; gradient and shadow will be set per theme */
    color: #fff;
}
.nav-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    padding: 10px 14px;
    font-size: 11px;
    transition: all 0.3s ease;
    border-radius: 12px;
    position: relative;
}
.nav-item i {
    font-size: 20px;
    margin-bottom: 4px;
    transition: transform 0.3s ease;
}
.nav-item span {
    font-size: 10px;
    font-weight: 500;
}
.nav-item.active {
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
    box-shadow: 0 2px 8px rgba(255, 255, 255, 0.2);
}
.nav-item:hover i {
    transform: translateY(-2px) rotate(5deg);
}
.nav-item:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: #333;
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 10px;
    white-space: nowrap;
    z-index: 10;
}
.modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 500px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 20px;
    border-radius: 12px;
    z-index: 1000;
    backdrop-filter: blur(12px);
}
.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
.modal-header h2 {
    font-size: 18px;
    font-weight: 600;
}
.modal-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: inherit;
}
.modal-content {
    font-size: 13px;
    line-height: 1.5;
}
.modal-content ul {
    list-style-type: disc;
    margin-left: 20px;
}
.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
}
.guide-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    backdrop-filter: blur(8px);
}
.guide-modal-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    padding: 20px;
    border-radius: 12px;
    backdrop-filter: blur(12px);
}
.dark-theme .guide-modal-content {
    background: rgba(30, 30, 46, 0.95);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
}
.light-theme .guide-modal-content {
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
}
.guide-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}
.guide-title {
    font-size: 20px;
    font-weight: 600;
    color: inherit;
}
.guide-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: inherit;
    opacity: 0.7;
    transition: opacity 0.3s;
}
.guide-close:hover {
    opacity: 1;
}
.guide-section {
    margin-bottom: 20px;
}
.guide-section h3 {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 10px;
    color: #4CAF50;
}
.guide-section p,
.guide-section li {
    font-size: 13px;
    line-height: 1.6;
    margin-bottom: 8px;
    opacity: 0.9;
}
.guide-section ul {
    padding-left: 20px;
}
.guide-highlight {
    background: rgba(76, 175, 80, 0.1);
    padding: 12px;
    border-radius: 8px;
    border-left: 3px solid #4CAF50;
    margin: 12px 0;
}
.accordion {
    margin-bottom: 10px;
    border-radius: 8px;
    overflow: hidden;
}
.accordion-header {
    padding: 15px;
    cursor: pointer;
    font-weight: 600;
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.accordion-content {
    padding: 15px;
    display: none;
    background: rgba(255, 255, 255, 0.1);
}
.accordion-content.active {
    display: block;
}
.accordion-content a {
    color: #4CAF50;
    text-decoration: underline;
}
.estimation-result {
    margin-top: 20px;
    padding: 15px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.1);
}
.chart-container {
    margin-top: 20px;
    max-width: 100%;
    height: 300px;
}
.delete-data-btn {
    background: #F44336;
    margin-top: 10px;
}
.delete-data-btn:hover {
    background: #D32F2F;
    box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
}

/* Custom styles for confirmation modal buttons.  The confirmation modal
   replaces native browser dialogs for destructive actions to maintain a
   consistent look and feel.  The “Yes” button uses a red palette to
   emphasise the irreversible nature of deletions, while the “Cancel”
   button is grey. */
.confirm-yes-btn {
    background: #F44336;
    color: white;
}
.confirm-yes-btn:hover {
    background: #D32F2F;
    box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
}
.confirm-cancel-btn {
    background: #9E9E9E;
    color: white;
}
.confirm-cancel-btn:hover {
    background: #757575;
    box-shadow: 0 4px 12px rgba(158, 158, 158, 0.4);
}
.pagination {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 10px;
}
.pagination button {
    padding: 8px 12px;
    border: none;
    border-radius: 8px;
    background: #4CAF50;
    color: white;
    cursor: pointer;
    font-size: 12px;
}
.pagination button:disabled {
    background: #ccc;
    cursor: not-allowed;
}
.success-check {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 250px;
    height: 250px;
    border-radius: 50%;
    background: none;
    animation: successPopBig 0.5s ease;
    z-index: 910;
}
.success-check i {
    color: white;
    font-size: 36px;
    line-height: 250px;
}
.login-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    backdrop-filter: blur(8px);
    background: rgba(0, 0, 0, 0.1);
    z-index: 909;
    border-radius: 0;
}
.landing-page {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    padding: calc(env(safe-area-inset-top, 0px) + 80px) 1rem 2rem 1rem;
    align-items: center;
    justify-content: center;
    position: relative;
    max-width: 800px;
    width: 100%;
    margin: 0 auto;
}
body.light-theme .landing-page {
    background: linear-gradient(135deg, #f5f7fa, #e0eafc);
    color: #333;
}
.landing-content {
    max-width: 1200px;
    width: 100%;
    margin: 0 auto;
    flex: 1;
}
.landing-hero {
    text-align: center;
    width: 100%;
    margin-bottom: 40px;
    animation: fadeInUp 1s ease forwards;
    opacity: 0;
    margin: 3rem 0 4rem;
}
.landing-logo {
    width: 100px;
    height: 100px;
    border-radius: 20px;
    background: linear-gradient(135deg, #4CAF50, #45a049);
    box-shadow: 0 12px 40px rgba(76, 175, 80, 0.4);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 25px;
    animation: logoFloat 3s ease-in-out infinite;
    transform: perspective(1000px) rotateX(5deg) translateZ(15px);
    transition: transform 0.3s ease;
}
.landing-logo:hover {
    transform: perspective(1000px) rotateX(0deg) translateZ(25px);
}
.landing-logo i {
    font-size: 42px;
    color: white;
}
.landing-title {
    font-size: 32px;
    font-weight: 700;
    margin-bottom: 12px;
    background: linear-gradient(135deg, #4CAF50, #2196F3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    line-height: 1.2;
}
body.light-theme .landing-title {
    background: linear-gradient(135deg, #4CAF50, #2196F3);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}
.landing-subtitle {
    font-size: 18px;
    opacity: 0.8;
    margin-bottom: 10px;
    font-weight: 500;
}
.landing-description {
    font-size: 14px;
    opacity: 0.7;
    line-height: 1.6;
    margin-bottom: 30px;
    max-width: 600px;
    margin-left: auto;
    margin-right: auto;
}
.landing-actions {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
    margin-bottom: 40px;
}
.landing-btn {
    padding: 14px 28px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    transform: perspective(1000px) translateZ(10px);
    display: flex;
    align-items: center;
    gap: 10px;
    min-width: 160px;
    justify-content: center;
    text-decoration: none;
    position: relative;
    backdrop-filter: blur(12px);
    animation: breathing 5s ease-in-out infinite;
}
.landing-btn:hover {
    transform: perspective(1000px) translateZ(20px) translateY(-2px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
}
.landing-btn.primary {
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
}
.landing-btn.primary:hover {
    transform: translateY(-3px);
    box-shadow: 0 10px 25px rgba(76, 175, 80, 0.6);
}
.landing-btn.primary.pulse {
    animation: pulse 2s infinite;
}
.landing-btn.secondary {
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: inherit;
}
.dark-theme .landing-btn.secondary {
    background: rgba(50, 50, 70, 0.6);
    border-color: rgba(255, 255, 255, 0.1);
}
.light-theme .landing-btn.secondary {
    background: rgba(220, 220, 220, 0.6);
    border-color: rgba(0, 0, 0, 0.1);
}
body.light-theme .landing-btn.secondary {
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(0, 0, 0, 0.1);
    color: #333;
}
.landing-btn.secondary:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-3px);
}
.landing-btn i {
    transition: transform 0.3s ease;
}
.landing-btn:hover i {
    transform: translateY(-2px) rotate(5deg);
}
.landing-features {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 20px;
    width: 100%;
    margin-bottom: 40px;
}
.feature-card {
    backdrop-filter: blur(12px);
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transform: perspective(1000px) rotateX(3deg) translateZ(10px);
    background: rgba(255, 255, 255, 0.05);
}
.dark-theme .feature-card {
    background: rgba(40, 40, 60, 0.6);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}
.light-theme .feature-card {
    background: rgba(245, 245, 245, 0.7);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    border-color: rgba(0, 0, 0, 0.1);
}
body.light-theme .feature-card {
    background: rgba(255, 255, 255, 0.85);
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
}
.feature-card:hover {
    transform: perspective(1000px) rotateX(0deg) translateZ(20px) translateY(-3px);
    transform: translateY(-5px);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
}
.feature-icon {
    width: 56px;
    height: 56px;
    border-radius: 14px;
    background: linear-gradient(135deg, #4CAF50, #2196F3);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 16px;
    box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
    transform: perspective(1000px) translateZ(5px);
}
.feature-icon i {
    font-size: 20px;
    color: white;
}
.feature-title {
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 10px;
    color: inherit;
}
.feature-description {
    font-size: 13px;
    opacity: 0.8;
    line-height: 1.5;
}
body.light-theme .feature-title,
body.light-theme .feature-description {
    color: #333;
}
.landing-footer {
    text-align: center;
    opacity: 0.6;
    font-size: 13px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-top: auto;
    margin-bottom: 20px;
    padding: 1.5rem 0;
}
.footer-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
}
.footer-logo {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-weight: 500;
}
.footer-links {
    display: flex;
    gap: 1.5rem;
}
.footer-links a {
    color: rgba(255, 255, 255, 0.7);
    text-decoration: none;
    transition: color 0.3s;
}
.footer-links a:hover {
    color: white;
}
body.light-theme .footer-links a {
    color: rgba(0, 0, 0, 0.6);
}
body.light-theme .footer-links a:hover {
    color: #000;
}
.back-icon {
    position: fixed;
    top: 10px;
    right: 10px;
    width: 32px;
    height: 32px;
    background-color: #28a745;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    border-radius: 50%;
    text-decoration: none;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    transition: background-color 0.3s;
    z-index: 908;
}
.back-icon:hover {
    background-color: #218838;
}
.bubble {
    position: fixed;
    bottom: -100px;
    background: rgba(255, 255, 255, 0.15);
    border-radius: 50%;
    animation: rise 15s infinite ease-in;
    z-index: 0;
}
.loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255,255,255,.3);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
    margin-left: 10px;
}
.btn, .landing-btn, td button, .switch-btn {
    position: relative;
    overflow: hidden;
}
.btn:active, .landing-btn:active, td button:active, .switch-btn:active {
    transform: scale(0.96);
}
.ripple-anim {
    position: absolute;
    border-radius: 50%;
    background: rgba(255,255,255,0.5);
    width: 10px;
    height: 10px;
    transform: scale(0);
    animation: ripple 0.6s linear;
    pointer-events: none;
}
@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
@keyframes logoFloat {
    0%, 100% {
        transform: perspective(1000px) rotateX(5deg) translateZ(15px) translateY(0px);
    }
    50% {
        transform: perspective(1000px) rotateX(5deg) translateZ(15px) translateY(-8px);
    }
}
@keyframes spin {
    to { transform: rotate(360deg); }
}
@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
    }
}
@keyframes ripple {
    to {
        transform: scale(20);
        opacity: 0;
    }
}
@keyframes fadeSlideIn {
    from {
        opacity: 0;
        transform: translateY(15px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
@keyframes fadeUp {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
@keyframes successPop {
    0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
    }
    50% {
        opacity: 1;
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
    }
}
@keyframes successPopBig {
    0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
    60% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
}
@keyframes shakeAnim {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    50% { transform: translateX(5px); }
    75% { transform: translateX(-5px); }
}
@keyframes slideFromLeft {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
}
@keyframes slideFromRight {
    from { opacity: 0; transform: translateX(20px); }
    to { opacity: 1; transform: translateX(0); }
}
@keyframes rise {
    0% { transform: translateY(0) scale(1); opacity: 0.7; }
    50% { opacity: 0.5; }
    100% { transform: translateY(-110vh) scale(1.2); opacity: 0; }
}
@keyframes fadeSlideUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}
@keyframes popIn {
    0% { transform: scale(0); opacity: 0; }
    80% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); }
}
@keyframes fadeInOverlay {
    to { opacity: 1; }
}
@keyframes fadeOutOverlay {
    to { opacity: 0; }
}
@keyframes popScale {
    0% { transform: scale(0); opacity: 0; }
    60% { transform: scale(1.2); opacity: 1; }
    100% { transform: scale(1); }
}
@media (max-width: 768px) {
    .landing-title {
        font-size: 2rem;
    }
    .landing-subtitle {
        font-size: 1.1rem;
    }
    .landing-description {
        font-size: 0.95rem;
    }
    .footer-content {
        flex-direction: column;
        gap: 1rem;
    }
}
@media (max-width: 600px) {
    .landing-page {
        padding: 20px;
    }
    .landing-title {
        font-size: 24px;
    }
    .landing-subtitle {
        font-size: 16px;
    }
    .landing-description {
        font-size: 13px;
    }
    .landing-actions {
        flex-direction: column;
        align-items: center;
    }
    .landing-btn {
        width: 100%;
        max-width: 280px;
    }
    .landing-features {
        grid-template-columns: 1fr;
    }
    .guide-modal-content {
        padding: 15px;
        width: 95%;
    }
    .container, .login-container {
        max-width: 100%;
        padding: 10px;
        padding-bottom: 80px;
        margin-top: 40px;
    }
    .nav-bar {
        padding: 8px;
        bottom: 10px;
    }
    .nav-item {
        font-size: 8px;
        padding: 6px 8px;
    }
    .nav-item i {
        font-size: 16px;
    }
    #educationContent {
        font-size: 12px;
        line-height: 1.4;
        max-width: 100%;
        overflow-wrap: break-word;
    }
    #educationContent table {
        width: 100%;
        display: block;
        overflow-x: auto;
        font-size: 9px;
        border-collapse: collapse;
        margin: 12px 0;
    }
    #educationContent th,
    #educationContent td {
        padding: 4px 6px;
        word-break: break-word;
        text-align: left;
        border: 1px solid rgba(0,0,0,0.1);
    }
    #reportSection {
        margin-top: 48px;
    }
}
@media (max-width: 480px) {
    .landing-hero {
        margin: 2rem 0;
    }
    .landing-title {
        font-size: 1.8rem;
    }
    .landing-features {
        grid-template-columns: 1fr;
    }
}
.page-fade-in {
    animation: fadeSlideIn 0.5s ease;
}
.staggered {
    opacity: 0;
    transform: translateY(20px);
    animation: fadeUp 0.6s ease forwards;
}
.shake {
    animation: shakeAnim 0.4s ease;
}
.page-slide-left {
    animation: slideFromLeft 0.4s ease;
}
.page-slide-right {
    animation: slideFromRight 0.4s ease;
}
.header {
    padding: 20px 24px !important;
    margin-bottom: 16px !important;
    border-radius: 16px 16px 0 0 !important;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
.header h1 {
    font-size: 24px !important;
    margin-bottom: 6px !important;
    font-weight: 700;
}
.header .subtitle {
    font-size: 14px !important;
    opacity: 0.8;
}
.page-fade {
    animation: fadeInPage 0.4s ease-in-out;
}
@keyframes fadeInPage {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
button, .btn, .landing-btn, .switch-btn {
    position: relative;
    overflow: hidden;
}
button:focus, .btn:focus, .landing-btn:focus, .switch-btn:focus {
    outline: none;
}
button::after, .btn::after, .landing-btn::after, .switch-btn::after {
    content: "";
    position: absolute;
    background: rgba(255,255,255,0.5);
    border-radius: 50%;
    width: 10px;
    height: 10px;
    transform: scale(0);
    opacity: 0.7;
    pointer-events: none;
}
button:active::after, .btn:active::after, .landing-btn:active::after, .switch-btn:active::after {
    transform: scale(20);
    opacity: 0;
    transition: transform 0.6s, opacity 0.6s;
}
.page-transition {
    animation: fadePage 0.4s ease-in-out;
}
@keyframes fadePage {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
#loadingOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(3px);
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: white;
}
#loadingOverlay .loading-spinner {
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid #4CAF50;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin-bottom: 12px;
}
#loadingOverlay .loading-text {
    font-size: 14px;
    font-weight: 500;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}
.header {
    padding-top: env(safe-area-inset-top); 
    padding-top: constant(safe-area-inset-top); 
}
html, body {
    margin: 0;
    padding: 0;
}
html, body {
    margin: 0;
    padding: 0;
}
.header {
    padding-top: calc(env(safe-area-inset-top, 0px) + 4px);
    padding-bottom: 8px;
}
@supports not (padding-top: env(safe-area-inset-top)) {
    .header {
        padding-top: 8px;
    }
}
.action-row td {
    padding: 8px;
    background: rgba(255,255,255,0.05);
    /* Each button now resides in its own table cell, so use default table cell layout */
    display: table-cell;
    text-align: left;
}
.action-row button {
    margin-right: 6px;
    padding: 6px 10px;
    font-size: 12px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: 0.3s;
    display: inline-flex;
    align-items: center;
    gap: 4px;
}
.action-row .detail-btn {
    background: #2196F3;
    color: white;
}
.action-row .detail-btn:hover {
    background: #1976D2;
}
.action-row .share-btn {
    background: #25D366;
    color: white;
}
.action-row .share-btn:hover {
    background: #20B058;
}
.action-row .edit-btn {
    background: #FFC107;
    color: #333;
}
.action-row .edit-btn:hover {
    background: #FFB300;
}
/* Delete button styling: uses a red palette to indicate a destructive action.  Hovering
   slightly darkens the background to provide visual feedback. */
.action-row .delete-btn {
    background: #F44336;
    color: #fff;
}
.action-row .delete-btn:hover {
    background: #D32F2F;
}
@media (min-width: 769px) and (max-width: 1024px) {
    .container, .login-container {
        max-width: 90%;
        padding: 20px;
        margin: 0 auto; 
    }
    .landing-content {
        display: flex;
        flex-direction: column;
        align-items: center; 
    }
    .landing-features {
        grid-template-columns: repeat(2, 1fr);
    }
    .landing-title {
        font-size: 28px;
    }
    .landing-subtitle {
        font-size: 18px;
    }
    .nav-bar {
        max-width: 90%;
        margin: 0 auto; 
    }
}
@media (min-width: 1025px) {
    .container, .login-container {
        max-width: 1100px;
        padding: 24px;
        margin: 0 auto; 
    }
    .landing-content {
        display: flex;
        flex-direction: column;
        align-items: center; 
    }
    .landing-features {
        grid-template-columns: repeat(3, 1fr);
    }
    .landing-title {
        font-size: 32px;
    }
    .landing-subtitle {
        font-size: 20px;
    }
    .nav-bar {
        max-width: 1100px;
        margin: 0 auto; 
    }
    .table-container {
        max-height: none;
        overflow-y: visible;
    }
}
@media (min-width: 769px) {
    .card {
        margin: 20px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .card:hover {
        transform: translateY(-4px);
        box-shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    }
    .btn:hover, .landing-btn:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
    }
    .feature-icon i {
        font-size: 24px;
    }
    .nav-item i {
        font-size: 20px;
    }
    .landing-features {
        gap: 28px;
    }
    .landing-hero {
        margin-bottom: 60px;
    }
}
.header, .nav-bar {
    background: rgba(255, 255, 255, 0.8); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    transition: background 0.3s ease;
}
body.dark-theme .header, 
body.dark-theme .nav-bar {
    background: rgba(30, 30, 46, 0.7); 
}
.page-fade-in, .page-transition {
    animation: fadeSlideInCustom 0.5s ease;
}
@keyframes fadeSlideInCustom {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
:root {
    --primary-color: #4CAF50;
    --secondary-color: #2196F3; 
}
.btn.secondary {
    background: linear-gradient(135deg, var(--secondary-color), #1976D2);
    color: #fff;
    box-shadow: 0 6px 20px rgba(33, 150, 243, 0.3);
}
.btn.secondary:hover {
    box-shadow: 0 8px 24px rgba(33, 150, 243, 0.4);
    transform: translateY(-2px);
}
.card, .login-card, .landing-btn, .btn, .switch-btn, input, select, textarea, .feature-card, .modal {
    border-radius: 14px;
}
body.dark-theme #inlineStatus {
    color: rgba(224, 224, 224, 0.9) !important;
    background: rgba(30, 30, 46, 0.7) !important;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}
.theme-toggle,
.data-management-toggle {
    position: absolute !important;
    width: 44px !important;
    height: 44px !important;
    border-radius: 12px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    cursor: pointer !important;
    transition: all 0.25s ease !important;
    font-size: 16px !important;
    border: none !important;
    z-index: 100 !important;
}
.theme-toggle {
    top: 20px !important;
    left: 20px !important;
    background: rgba(224, 224, 224, 0.1) !important;
    color: #4CAF50 !important;
}
.data-management-toggle {
    top: 80px !important;
    left: 20px !important;
    background: rgba(224, 224, 224, 0.1) !important;
    color: #F44336 !important;
}
.theme-toggle:hover {
    background: rgba(224, 224, 224, 0.15) !important;
    transform: translateY(-1px) !important;
}
.data-management-toggle:hover {
    background: rgba(224, 224, 224, 0.15) !important;
    transform: translateY(-1px) !important;
}
body.light-theme .theme-toggle,
body.light-theme .data-management-toggle {
    background: rgba(100, 100, 100, 0.1) !important;
}
@media (max-width: 600px) {
    .theme-toggle, .data-management-toggle {
        width: 40px !important;
        height: 40px !important;
        font-size: 14px !important;
    }
    .data-management-toggle {
        top: 70px !important;
    }
}
.login-card {
    backdrop-filter: blur(20px);
    padding: 50px 45px;
    border-radius: 24px;
    transform: perspective(1000px) rotateX(3deg) translateZ(20px);
    transition: all 0.4s ease;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
    border: 2px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 20px 60px rgba(0,0,0,0.2), 0 5px 15px rgba(0,0,0,0.1);
    animation: fadeSlideUp 0.8s ease;
    position: relative;
    overflow: hidden;
}
.login-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    transition: all 0.8s;
    z-index: 1;
}
.login-card:hover::before {
    left: 100%;
}
.login-card > * {
    position: relative;
    z-index: 2;
}
.login-card:hover {
    transform: perspective(1000px) rotateX(0deg) translateZ(35px) scale(1.02);
    box-shadow: 0 25px 80px rgba(0,0,0,0.25), 0 10px 25px rgba(0,0,0,0.15);
}
.logo-text h1 {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 8px;
    line-height: 1.3;
    text-align: left;
    background: linear-gradient(135deg, #4CAF50, #2196F3, #9C27B0);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-size: 200% 200%;
    animation: gradientShift 3s ease-in-out infinite;
}
.login-input-card {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
    backdrop-filter: blur(12px);
    border-radius: 20px;
    padding: 30px;
    margin-bottom: 35px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255,255,255,0.2);
    transition: all 0.4s ease;
    border: 1px solid rgba(255, 255, 255, 0.15);
}
.input-wrapper input {
    padding: 18px 20px 18px 55px !important;
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 14px;
    font-size: 15px;
    font-weight: 500;
    letter-spacing: 0.5px;
    transition: all 0.3s ease;
}
@keyframes gradientShift {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}
@keyframes floatingGlow {
    0%, 100% { 
        box-shadow: 0 5px 25px rgba(76, 175, 80, 0.3);
        transform: translateY(0px);
    }
    50% { 
        box-shadow: 0 8px 35px rgba(76, 175, 80, 0.4);
        transform: translateY(-3px);
    }
}

 

/* Hide damage page and related UI components */
[data-page="damagePage"],
#damagePage,
#damageDetailModal {
    display: none !important;
}

/* Improve navigation bar readability in light theme */
body.light-theme .nav-item {
    color: #2e7d32;
}
body.light-theme .nav-item.active {
    background: rgba(76, 175, 80, 0.3);
    color: #2e7d32;
}

/* Enhance pagination button appearance */
.pagination button {
    padding: 8px 16px;
    border-radius: 20px;
    background: linear-gradient(135deg, #4CAF50, #81C784);
    color: white;
    font-size: 13px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    transition: background 0.3s ease, transform 0.3s ease;
}
.pagination button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}
.pagination button:disabled {
    background: #ccc;
    color: #888;
}

/* Make education tables scrollable with fixed height */
#educationContent table {
    width: 100%;
    max-width: 100%;
    display: block;
    max-height: 400px;
    overflow: auto;
}
#educationContent th,
#educationContent td {
    white-space: nowrap;
}

/* Enhance dashboard (main page) cards for a more polished look */
#mainPage .card {
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(0, 0, 0, 0.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}
body.dark-theme #mainPage .card {
    background: rgba(40, 40, 60, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

/* Emphasize shift information on dashboard */
.shift-info {
    font-size: 14px;
    margin-bottom: 12px;
    font-weight: 600;
    color: #4CAF50;
}
body.dark-theme .shift-info {
    color: #A5D6A7;
}

/* Style switch type buttons to be more visually appealing */
.switch-type .switch-btn {
    background: rgba(76, 175, 80, 0.05);
    border: 1px solid rgba(76, 175, 80, 0.2);
    transition: background 0.3s ease, box-shadow 0.3s ease;
}
.switch-type .switch-btn:hover {
    background: rgba(76, 175, 80, 0.1);
}
.switch-type .switch-btn.active {
    background: #4CAF50;
    color: #fff;
    box-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
}

/* -------------------------------------------------------------
   Custom overrides and enhancements
   These rules refine the appearance of the navigation bar, pagination
   buttons and attendance dashboard.  They are appended near the end
   of the stylesheet to ensure they override earlier definitions.  */
/* Light theme navigation tweaks */
/* Light theme navigation bar background */
body.light-theme .nav-bar {
    background: #ffffff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}
body.light-theme .nav-item {
    color: #4CAF50;
}
body.light-theme .nav-item i {
    color: inherit;
}
body.light-theme .nav-item.active {
    background: #4CAF50;
    color: #ffffff;
}
body.light-theme .nav-item.active i,
body.light-theme .nav-item.active span {
    color: #ffffff;
}

/* Minimalist pagination controls */
.pagination button {
    padding: 6px 12px;
    border-radius: 8px;
    background: none;
    border: 1px solid #4CAF50;
    color: #4CAF50;
    font-size: 13px;
    box-shadow: none;
    transition: background 0.3s ease, color 0.3s ease;
}
.pagination button:hover:not(:disabled) {
    background: #4CAF50;
    color: #ffffff;
}
.pagination button:disabled {
    background: #e0e0e0;
    color: #999999;
    border-color: #e0e0e0;
}

/* Attendance input redesign */
.attendance-inputs {
    display: flex;
    justify-content: space-between;
    gap: 20px;
    margin-bottom: 12px;
}
.attendance-input-card {
    flex: 1;
    background: rgba(76, 175, 80, 0.05);
    border: 1px solid rgba(76, 175, 80, 0.2);
    border-radius: 12px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.attendance-input-card i {
    font-size: 20px;
    color: #4CAF50;
    margin-bottom: 8px;
}
.attendance-input-card input {
    width: 60px;
    font-size: 16px;
    padding: 4px;
    text-align: center;
    border: none;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    margin-bottom: 4px;
    color: inherit;
}
.attendance-input-card span {
    font-size: 12px;
    color: #555555;
}
body.dark-theme .attendance-input-card {
    background: rgba(40, 40, 60, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.1);
}

    /* Badges for attendance counts in the staff list.  Each staff entry will
       display their total instances of being late and leaving early.  The
       background colours correspond to the colours used in the summary
       progress bar: red for late arrivals and orange for early departures.  */
    .attendance-count {
        margin-left: 6px;
        font-size: 12px;
        display: inline-flex;
        gap: 4px;
        align-items: center;
    }
    .attendance-count .late-badge,
    .attendance-count .early-badge {
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        display: inline-block;
        line-height: 1;
    }
    .attendance-count .late-badge {
        background: #e53935;
        color: #fff;
    }
    .attendance-count .early-badge {
        background: #FFCA28;
        color: #000;
    }

    /* Additional badges for staff activity metrics.  The checklist badge
       shows the number of checklist submissions by a staff member, while
       the on‑time badge displays their punctuality rate as a percentage.
       We use distinct colours to differentiate these metrics: blue for
       checklist submissions and green for on‑time arrival rates. */
    .attendance-count .checklist-badge {
        background: #2196F3;
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        display: inline-block;
        line-height: 1;
    }
    .attendance-count .ontime-badge {
        background: #4CAF50;
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        display: inline-block;
        line-height: 1;
    }

    /* Additional badge for displaying the average input time of each staff member.
       The purple colour complements the existing palette and differentiates this
       metric from checklist counts and punctuality percentages. */
    .attendance-count .avgtime-badge {
        background: #9C27B0;
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        display: inline-block;
        line-height: 1;
    }
body.dark-theme .attendance-input-card i {
    color: #A5D6A7;
}
body.dark-theme .attendance-input-card input {
    background: rgba(255, 255, 255, 0.1);
    color: #e0e0e0;
}
body.dark-theme .attendance-input-card span {
    color: #cccccc;
}

/* Attendance summary card styles */
.attendance-summary-card {
    text-align: center;
}

/* Additional styles for the enhanced staff list */
.staff-search {
    width: 100%;
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid rgba(0, 0, 0, 0.1);
    margin-bottom: 10px;
    font-size: 13px;
}
/* Sort dropdown styling for staff list */
.staff-sort {
    width: 100%;
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid rgba(0, 0, 0, 0.1);
    margin-bottom: 10px;
    font-size: 13px;
}
body.dark-theme .staff-sort {
    background: rgba(50, 50, 70, 0.8);
    color: #e0e0e0;
}
body.light-theme .staff-sort {
    background: rgba(255, 255, 255, 0.8);
    color: #333;
}
body.dark-theme .staff-search {
    background: rgba(50, 50, 70, 0.8);
    color: #e0e0e0;
}
body.light-theme .staff-search {
    background: rgba(255, 255, 255, 0.8);
    color: #333;
}
#toggleStaffListBtn {
    margin-top: 8px;
    display: block;
    width: 100%;
    padding: 8px 12px;
    font-size: 13px;
    font-weight: 600;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background: linear-gradient(135deg, #4CAF50, #45a049);
    color: white;
    transition: background 0.3s ease;
}
#toggleStaffListBtn:hover {
    background: linear-gradient(135deg, #45a049, #4CAF50);
}
/* Hide staff list items beyond the first five when collapsed */
.staff-list.collapsed li:nth-child(n+6) {
    display: none;
}
.progress-container {
    width: 100%;
    background: rgba(76, 175, 80, 0.08);
    border-radius: 12px;
    /* Increase the bar height for better visibility */
    height: 22px;
    overflow: hidden;
    margin-top: 12px;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
}
.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #e53935, #FFCA28);
    width: 0%;
    transition: width 0.5s ease;
    border-radius: 12px;
}
/*
    Custom class for the attendance Lottie animation.  By making the
    width a percentage of its parent container and restricting the
    maximum width, the animation scales gracefully across screen sizes.
    The height is defined to keep a consistent aspect ratio.
*/
.attendance-anim {
    width: 100%;
    max-width: 360px;
    height: 200px;
    margin: 0 auto 32px auto;
}

/* Small tag used to display the NIK next to a staff member's name. It uses
   reduced font size and opacity to avoid overwhelming the primary name. */
/* Small tag used to display the NIK next to a staff member's name. The default width
   and right‑alignment have been removed to ensure the NIK appears immediately
   after the name. A space character is inserted in the markup to separate the
   name and NIK, so no additional margin is needed here. */
.nik-tag {
    font-size: 11px;
    opacity: 0.7;
    /* No additional margin is applied here because a single space character is
       inserted between the staff name and the NIK tag in the markup. */
    margin-left: 0;
}
#progressText {
    /* Display the legend as a horizontal flex row so each legend item
       (colour swatch + label) sits neatly next to each other.  We also
       nudge the margin to give breathing room above the bar. */
    font-size: 14px;
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 12px;
    font-weight: 600;
}
</style>
</head>
<body class="light-theme">
    <div class="theme-toggle" id="themeToggle">
        <i id="themeIcon" class="fas fa-sun"></i>
    </div>
    <!-- Removed the standalone data management toggle.  Access to the data
         management page is now provided via a navigation item (shown only
         for privileged users) instead of a floating trash icon under the
         theme button.  This simplifies the interface and prevents an
         accidental click on a destructive action. -->
<div id="loadingOverlay" style="display:none;">
    <div class="loading-spinner"></div>
    <div class="loading-text">Memproses...</div>
</div>
    <nav class="nav-bar" id="navBar" style="display: none;">
        <!-- New nav item for dashboard (attendance page) placed on the far left -->
        <div class="nav-item" data-page="attendancePage" data-tooltip="Kehadiran">
            <i class="fas fa-user-check"></i>
            <span>Dashboard</span>
        </div>
        <div class="nav-item active" data-page="mainPage" data-tooltip="Checklist">
            <i class="fas fa-list-check"></i>
            <span>Checklist</span>
        </div>
        <!-- Nav item for Meter Lapangan removed as per updated requirements -->
        <!-- Data management nav item removed; deletion functionality is now part of report actions -->
        <!-- Kerusakan navigation item removed as damage reporting is no longer part of the system -->
        <div class="nav-item" data-page="estimationPage" data-tooltip="Estimasi">
            <i class="fas fa-chart-line"></i>
            <span>Estimasi</span>
        </div>
        <div class="nav-item" data-page="educationPage" data-tooltip="Edukasi">
            <i class="fas fa-book"></i>
            <span>Edukasi</span>
        </div>
        <!-- New nav item for the analysis page.  This page visualises numeric checklist
             fields over time and summarises the results.  Users can quickly spot
             trends and outliers in the recorded data. -->
        <div class="nav-item" data-page="analysisPage" data-tooltip="Analisis">
            <i class="fas fa-chart-bar"></i>
            <span>Analisis</span>
        </div>
        <!-- Removed the data management nav item.  Deletion of individual reports can be performed directly within the report table. -->
    </nav>
<div id="landingPage" class="landing-page">
    <div class="landing-content">
        <div class="landing-hero">
            <!-- Animated illustration for the hero section.  This uses a
                 local Lottie file to give the landing page a dynamic,
                 glass‑like feel.  The animation container has its size
                 controlled via the .landing-animation class defined in the
                 stylesheet above. -->
            <div id="landingAnimation" class="landing-animation"></div>
            <h1 class="landing-title">Water Monitoring & Maintaining System</h1>
            <p class="landing-subtitle">Sistem Terintegrasi untuk Manajemen Air yang Lebih Baik</p>
            <div class="landing-actions">
                <button class="landing-btn primary pulse" id="loginFromLanding">
                    <i class="fas fa-sign-in-alt"></i>
                    <span>Masuk Sistem</span>
                </button>
                <button class="landing-btn secondary" id="showGuide">
                    <i class="fas fa-book"></i>
                    <span>Panduan Penggunaan</span>
                </button>
            </div>
        </div>
        <div class="landing-features">
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-list-check"></i>
                </div>
                <h3 class="feature-title">Checklist Harian</h3>
                <p class="feature-description">
                    Monitoring tinggi bak distribusi, pompa transfer, hydran, dan meter air dengan sistem shift otomatis
                </p>
            </div>
            <!-- Removed Meter Lapangan feature card as the meter reading functionality has been retired. -->
            <!-- Removed the 'Laporan Kerusakan' feature card to hide damage reporting from the landing page -->
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-chart-line"></i>
                </div>
                <h3 class="feature-title">Estimasi Konsumsi</h3>
                <p class="feature-description">
                    Perhitungan proyeksi pemakaian air berdasarkan data historis dengan visualisasi grafik
                </p>
            </div>

            <!-- Additional feature cards to give visitors more context about the system. -->
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-user-clock"></i>
                </div>
                <h3 class="feature-title">Dashboard Kehadiran</h3>
                <p class="feature-description">
                    Pantau kedisiplinan staf melalui laporan keterlambatan, pulang cepat, dan daftar kehadiran harian.
                </p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-chart-pie"></i>
                </div>
                <h3 class="feature-title">Analisis Checklist</h3>
                <p class="feature-description">
                    Visualisasi tren data checklist untuk setiap parameter dan analisis statistik untuk membantu evaluasi.
                </p>
            </div>
            <div class="feature-card">
                <div class="feature-icon">
                    <i class="fas fa-info-circle"></i>
                </div>
                <h3 class="feature-title">Panduan Singkat</h3>
                <p class="feature-description">
                    Masukkan NIK CA00XXX untuk login, isi checklist sesuai shift, gunakan menu Estimasi untuk proyeksi, pelajari sistem lewat Edukasi, dan pantau tren melalui Analisis.
                </p>
            </div>
        </div>
    </div>
    <div class="landing-footer">
        <div class="footer-content">
            <div class="footer-logo">
                <span>© 2025 Water Treatment Department. All rights reserved.</span>
            </div>
        </div>
    </div>
</div>
<div id="guideModal" class="guide-modal">
    <div class="guide-modal-content">
        <div class="guide-header">
            <h2 class="guide-title">
                <i class="fas fa-book" style="margin-right: 8px; color: #4CAF50;"></i>
                Panduan Penggunaan Sistem
            </h2>
            <button class="guide-close" id="closeGuide">&times;</button>
        </div>
        <div class="guide-section">
            <h3><i class="fas fa-user-check" style="margin-right: 6px;"></i>Login & Akses</h3>
            <ul>
                <li>Masukkan NIK dengan format CA00XXX untuk login</li>
                <li>Sistem akan mengenali nama user otomatis</li>
            </ul>
        </div>
        <div class="guide-section">
            <h3><i class="fas fa-list-check" style="margin-right: 6px;"></i>Checklist Harian</h3>
            <p>Fitur utama untuk monitoring sistem air harian:</p>
            <ul>
                <li><strong>Checklist Masuk:</strong> Jam 07:00-07:30, 15:00-15:30, 23:00-23:30</li>
                <li><strong>Checklist Pulang:</strong> Jam 14:30-15:00, 22:30-23:00, 06:30-07:00</li>
                <li><strong>Custom Checklist:</strong> Dapat dilakukan kapan saja</li>
                <li>Isi data tinggi bak RO, WWTP, PDAM dan status pompa</li>
                <li>Sistem otomatis menghitung status berdasarkan ketinggian air</li>
            </ul>
        </div>
        <!-- Meter Lapangan guide section removed since the feature has been deprecated -->
        <!-- Removed 'Laporan Kerusakan' guide section as damage reporting is not part of the system anymore -->
        <div class="guide-section">
            <h3><i class="fas fa-chart-line" style="margin-right: 6px;"></i>Estimasi Konsumsi</h3>
            <p>Perhitungan proyeksi pemakaian air:</p>
            <div class="guide-highlight">
                <p><strong>Input yang diperlukan:</strong> Tinggi bak (cm), pembacaan meter awal/akhir (m³), durasi estimasi (jam)</p>
            </div>
            <ul>
                <li>Sistem menghitung konsumsi per jam berdasarkan data historis</li>
                <li>Proyeksi pemakaian 24 jam dengan rekomendasi</li>
                <li>Grafik visualisasi dan tabel forecast</li>
                <li>Peringatan jika volume bak tidak mencukupi</li>
            </ul>
        </div>
        <div class="guide-section">
            <h3><i class="fas fa-book" style="margin-right: 6px;"></i>Katalog Edukasi</h3>
            <p>Materi pembelajaran sistem air:</p>
            <ul>
                <li><strong>K3:</strong> Prosedur keselamatan, penanganan darurat</li>
                <li><strong>Perpipaan:</strong> Jenis pipa, pemeliharaan, estimasi kehilangan</li>
                <li><strong>Mesin & Pompa:</strong> Spesifikasi, monitoring efisiensi</li>
                <li><strong>Valve & Hydran:</strong> Jenis dan fungsi masing-masing</li>
                <li><strong>Water Meter:</strong> Tipe meter dan cara pembacaan</li>
                <li><strong>Baku Mutu Air:</strong> Standar kualitas dan monitoring</li>
                <li><strong>WTP:</strong> Estimasi kebutuhan dan monitoring sistem</li>
            </ul>
        </div>
        <div class="guide-section">
            <h3><i class="fas fa-share-alt" style="margin-right: 6px;"></i>Tips Penggunaan</h3>
            <div class="guide-highlight">
                <p><strong>Penting:</strong> Pastikan semua field wajib terisi sebelum menyimpan data</p>
            </div>
            <ul>
                <li>Gunakan tema gelap/terang sesuai preferensi</li>
                <li>Data tersimpan otomatis di cloud dengan backup</li>
                <li>Notifikasi akan muncul untuk konfirmasi aksi</li>
                <li>Sistem otomatis update waktu dan shift</li>
                <li>Untuk masalah teknis, hubungi administrator</li>
            </ul>
        </div>
    </div>
</div>
<div id="loginPage" class="login-container">
    <a href="index.html" class="back-icon" title="Kembali ke Beranda">
        <i class="fa-solid fa-house"></i>
    </a>
<div id="loginOverlay" class="login-overlay" style="display: none;"></div>
<div class="success-check" id="successCheck" style="display:none; background:none;">
    <div id="successAnimation" style="width:250px; height:250px;"></div>
</div>
    <div class="login-card">
        <div class="logo-section horizontal-logo">
            <!-- Lottie animation for the login page.  Placed before the
                 logo text to provide a friendly, modern touch while
                 keeping the layout horizontally aligned. -->
            <div id="loginAnimation" class="login-animation"></div>
            <div class="logo-text">
                <h1>Water Monitoring & Maintaining System</h1>
                <div class="subtitle">WTP Department - Secure Login Portal</div>
            </div>
        </div>
        <div class="login-input-card">
            <div class="input-wrapper">
                <input type="text" id="nikInput" placeholder="Masukkan NIK (Contoh: CA00001)" required>
                <i class="fas fa-id-card input-icon"></i>
            </div>
            <!-- Added a second input for the user’s name.  The login process now
                 requires both a registered NIK and the matching name to
                 authenticate.  This prevents unknown identifiers from being
                 accepted and makes the login more secure. -->
            <div class="input-wrapper">
                <input type="text" id="nameInput" placeholder="Masukkan Nama Anda" required>
                <i class="fas fa-user input-icon"></i>
            </div>
            <button class="btn" id="loginButton">
                <i class="fas fa-sign-in-alt" style="margin-right: 8px;"></i>
                <span>Masuk</span>
            </button>
        </div>
        <div class="login-footer">
            <i class="fas fa-shield-alt"></i>
            <span>Secure Water Management System</span>
        </div>
    </div>
</div>
 
<div id="attendancePage" class="container" style="display:none;">
    <div class="header">
 
        <div id="attendanceAnim" class="attendance-anim"></div>
        <div class="greeting" id="attendanceGreeting">Selamat Pagi, User!</div>
        <h1>Dashboard Kehadiran</h1>
        <div class="subtitle">Pantau Kedisiplinan</div>
        <!-- Summary cards displaying the user’s lateness, early departures and
             daily checklist count.  These cards update dynamically when
             the attendance values change. -->
        <div class="dashboard-summary-cards">
            <div class="summary-card">
                <i class="fas fa-clock"></i>
                <div class="summary-title">Terlambat</div>
                <div id="summaryLate" class="summary-value">0</div>
            </div>
            <div class="summary-card">
                <i class="fas fa-forward"></i>
                <div class="summary-title">Pulang Cepat</div>
                <div id="summaryEarly" class="summary-value">0</div>
            </div>
            <div class="summary-card">
                <i class="fas fa-list-check"></i>
                <div class="summary-title">Checklist</div>
                <div id="summaryChecklist" class="summary-value">0</div>
            </div>
        </div>
    </div>
 
    <div class="card attendance-summary-card">
        <h2 style="margin-bottom: 12px; font-size: 18px; font-weight: 600;">Ringkasan Kehadiran</h2>
        <div class="progress-container">
            <div id="attendanceProgressBar" class="progress-bar"></div>
        </div>
        <div id="progressText">Belum ada data keterlambatan.</div>
    </div>
 
    <div class="card">
        <h2 style="margin-bottom: 12px; font-size: 18px; font-weight: 600;">Telat &amp; Pulang Cepat</h2>
            <!-- Updated description: the total infractions are no longer capped at 5.  Instead, 5 serves as a reminder threshold and users are free to record more than 5. -->
            <p style="font-size: 12px; opacity: 0.7; margin-bottom: 8px;">Catat jumlah keterlambatan dan pulang cepat Anda bulan ini (batas pengingat 5 kali, Anda boleh melebihi angka ini).</p>
        <div class="attendance-inputs">
            <div class="attendance-input-card">
                <i class="fas fa-clock"></i>
                <!-- Removed the hard cap of 5 for lateness.  We retain a reasonable upper bound to prevent excessively large input values from breaking the UI. -->
                <input type="number" id="lateInput" min="0" max="10" value="0">
                <span>Telat</span>
            </div>
            <div class="attendance-input-card">
                <i class="fas fa-forward"></i>
                <!-- Removed the hard cap of 5 for early departures.  A higher max allows users to record more than 5 instances, while still constraining the input range. -->
                <input type="number" id="earlyInput" min="0" max="10" value="0">
                <span>Pulang Cepat</span>
            </div>
        </div>
        <div id="attendanceSummary" style="font-size: 13px; margin-top: 6px; font-weight: 500;"></div>
    </div>
 
    <!--
        The standalone staff list card has been removed.  The staff list and
        associated toggle button are now integrated directly into the
        Aktivitas Staf card so that staff names, attendance badges and
        activity metrics live in one cohesive section.  This improves the
        flow of the dashboard by keeping all staff‑related information in
        one place.  See the updated userActivityCard markup below.
    -->
 
    <div class="card" id="activitySummaryCard">
        <h2 style="margin-bottom: 12px; font-size: 18px; font-weight: 600;">Ringkasan Checklist &amp; Staf</h2>
        <ul id="activitySummaryList" style="list-style: none; font-size: 13px; padding-left: 0;"></ul>
    </div>
 
    <!--
        Aktivitas Staf card now always visible.  It contains a doughnut chart
        summarising checklist submissions per staff member, a detailed
        contributor list with average input times and punctuality rates, and
        the complete staff roster with late/early/checklist/ontime badges.  A
        toggle button lets users collapse or expand the roster.  All staff
        appear by default (i.e. no initial collapse).
    -->
    <div class="card" id="userActivityCard">
        <!--
            This section visualises staff activity.  The chart shows the number
            of checklist submissions per user with colour‑coded slices.  The legend
            lists each user; clicking a legend item highlights that staff
            member in the summary below.  Additional metrics such as the
            average input time and punctuality are displayed beneath the
            chart.  See renderUserActivityDashboard() for the data logic.
        -->
        <h2 style="margin-bottom: 12px; font-size: 18px; font-weight: 600;">Aktivitas Staf</h2>
        <canvas id="userActivityChartCanvas" height="220" style="width:100%;max-width:100%;max-height:220px;"></canvas>
        <!-- Hide the separate top contributor list to avoid duplicating information.  All staff
             activity metrics (late/early counts, checklist submissions, average input time
             and punctuality) are now shown within the staff roster below.  The list
             remains in the DOM for compatibility but is hidden via inline style. -->
        <ul id="topContributorList" style="list-style:none; font-size: 12px; padding-left:0; margin-top:8px; display:none;"></ul>

        <!-- Integrated staff roster -->
        <h3 style="margin-top: 16px; font-size: 16px; font-weight: 600;">Daftar Staf</h3>
        <p class="staff-desc" style="font-size: 12px; opacity: 0.8; margin-bottom: 8px;">
            💡 Klik nama staf atau lingkaran warna di sebelahnya untuk menampilkan keterangan detail (jumlah telat, pulang cepat, checklist).
        </p>
        <!-- Show all staff by default; remove the 'collapsed' class.  The
             toggle button text reflects the current state via JS. -->
        <ul id="staffList" class="staff-list"></ul>
        <!--
             Toggle button removed; all staff are shown by default.  If
             collapse/expand functionality is reinstated in the future,
             reintroduce this button and the collapsed class on the
             staff-list element.
        -->
    </div>
</div>
<div id="mainPage" class="container page-fade" style="display:none;">
    <div class="header">
        <div id="anim1" style="width:400px;height:200px;margin:auto;margin-bottom:32px;"></div>
        <div class="greeting" id="greeting">Selamat Pagi, User!</div>
        <h1>Checklist Sistem Air</h1>
        <div class="subtitle">Monitoring & Pemeliharaan</div>

        <!-- Dashboard Kehadiran
             Menambahkan sebuah kartu ringkas di halaman utama untuk memantau
             keterlambatan (telat) dan pulang cepat.  Dashboard ini
             menggunakan input angka dengan batas maksimum 5 untuk masing‑masing
             kategori, dan menampilkan total kumulatif.  Bila gabungan
             keterlambatan dan pulang cepat mencapai 5 kali, akan muncul
             peringatan agar pengguna tidak lalai.  Nilai disimpan di
             localStorage sehingga bertahan antar kunjungan. -->
        <!-- old attendance dashboard removed: moved to dedicated attendancePage -->
    </div>
    <div class="card">
        <div class="shift-info">
            Shift: <span id="shiftInfo"></span> | Waktu: <span id="currentTime">00:00:00</span>
        </div>
    </div>
    <div class="card">
        <div class="switch-type">
            <button class="switch-btn active" id="switchMasuk">CHECKLIST MASUK</button>
            <button class="switch-btn" id="switchPulang">CHECKLIST PULANG</button>
            <button class="switch-btn" id="switchCustom">CUSTOM CHECKLIST</button>
        </div>
    </div>
    <div class="card" id="checklistFormContainer">
        <form id="checklistForm">
            <input type="hidden" id="bakRO">
            <input type="hidden" id="bakWWTP">
            <input type="hidden" id="statusPDAM">
            <!-- Additional selects shown only for custom checklist type.  Allows the user to
                 specify which shift the custom entry belongs to and whether it is for
                 a "Masuk" (arrival) or "Pulang" (departure) checklist.  These fields
                 remain hidden for the standard masuk/pulang modes. -->
            <div class="form-group" id="customOptions" style="display:none;">
                <select id="customShiftSelect">
                    <option value="">Pilih Shift...</option>
                    <option value="Satu">Shift Satu</option>
                    <option value="Dua">Shift Dua</option>
                    <option value="Tiga">Shift Tiga</option>
                </select>
                <select id="customTypeSelect" style="margin-top:10px;">
                    <option value="">Pilih Tipe...</option>
                    <option value="masuk">Masuk</option>
                    <option value="pulang">Pulang</option>
                </select>
            </div>
            <div class="form-group">
                <div class="input-group">
                    <input type="number" id="tinggiRO" placeholder="Ketinggian Bak RO (cm)" required>
                    <div class="unit">cm</div>
                </div>
            </div>
            <div class="section-divider"></div>
            <div class="form-group">
                <div class="input-group">
                    <input type="number" id="tinggiWWTP" placeholder="Ketinggian Bak Tampung WWTP (cm)" required>
                    <div class="unit">cm</div>
                </div>
            </div>
            <div class="section-divider"></div>
            <div class="form-group">
                <select id="pompa" required>
                    <option value="">Pilih Kondisi Pompa Transfer WWTP RO...</option>
                    <option value="ON">ON</option>
                    <option value="OFF">OFF</option>
                </select>
            </div>
            <div class="section-divider"></div>
            <div class="form-group">
                <div class="input-group">
                    <input type="number" id="tinggiPDAM" placeholder="Ketinggian Bak Input Air PDAM (cm)" required>
                    <div class="unit">cm</div>
                </div>
            </div>
            <div class="form-group">
                <select id="hydrantStatus" required>
                    <option value="">Pilih Status Hydrant...</option>
                    <option value="ON">ON</option>
                    <option value="OFF">OFF</option>
                </select>
            </div>
            <div class="form-group">
                <select id="AStatus" required>
                    <option value="">Pilih Status Penggunaan Air Blok A...</option>
                    <option value="PDAM">PDAM</option>
                    <option value="RO">RO</option>
                </select>
            </div>
            <div class="form-group">
                <select id="EStatus" required>
                    <option value="">Pilih Status Penggunaan Air Blok E...</option>
                    <option value="PDAM">PDAM</option>
                    <option value="RO">RO</option>
                </select>
            </div>
            <div class="form-group">
                <select id="damkar" required>
                    <option value="">Pilih Status Penggunaan Air Damkar...</option>
                    <option value="PDAM">PDAM</option>
                    <option value="RO">RO</option>
                </select>
            </div>
            <div class="section-divider"></div>
            <div class="form-group">
                <select id="supplyPDAM" required>
                    <option value="">Pilih Status Supply Air PDAM...</option>
                    <option value="Menyala">Menyala</option>
                    <option value="Mati">Mati</option>
                </select>
            </div>
            <div class="form-group">
                <input type="number" id="meterIndukPDAM" placeholder="Angka Meter Induk PDAM" required>
            </div>
            <div class="form-group">
                <input type="number" id="meterIndukWTP" placeholder="Angka Meter Induk WTP" required>
            </div>
            <div class="form-group">
                <div class="input-group">
                    <input type="number" id="PDAM" placeholder="Flow Input PDAM (m³)" required>
                    <div class="unit">m³</div>
                </div>
            </div>
            <div class="form-group">
                <div class="input-group">
                    <input type="number" id="flowPDAM" placeholder="Rate Input (m³/j) isi 0 jika pdam off" required>
                    <div class="unit">m³/j</div>
                </div>
            </div>
            <div class="form-group">
                <input type="text" id="catatan" placeholder="Catatan Tambahan (Opsional)">
            </div>
            <button type="submit" class="btn" id="saveChecklistButton">
                <i class="fas fa-save"></i>
                <span class="btn-text">Simpan Checklist</span>
            </button>
        </form>
    </div>
    <div class="card" id="reportSection">
        <h2 style="margin-bottom: 12px; font-size: 18px; font-weight: 600;">Laporan Checklist</h2>
        <div class="filter-group">
            <select id="filterDate">
                <option value="">Semua Tanggal</option>
            </select>
            <select id="filterShift">
                <option value="">Semua Shift</option>
                <option value="masuk">Masuk</option>
                <option value="pulang">Pulang</option>
                <option value="custom">Custom</option>
            </select>
            <select id="filterNIK">
                <option value="">Semua Pengguna</option>
            </select>
        </div>
        <p style="font-size: 12px; opacity: 0.7; margin-bottom: 8px;">
    💡 Geser ke samping untuk mengakses seluruh kolom laporan
</p>
        <div class="table-container">
            <table id="reportTable">
                <thead>
                    <tr>
                        <th>Tanggal</th>
                        <th>Waktu</th>
                        <th>Shift</th>
                        <th>Penginput</th>
                    </tr>
                </thead>
                <tbody id="reportBody"></tbody>
            </table>
        </div>
        <div class="pagination" id="reportPagination"></div>
    </div>
</div>
<div id="modalOverlay" class="modal-overlay"></div>
<div id="detailModal" class="modal">
    <div class="modal-header">
        <h2>Detail Checklist</h2>
        <button class="modal-close" id="modalClose">&times;</button>
    </div>
    <div class="modal-content" id="modalContent"></div>
</div>
<!-- Modal for displaying detailed damage report and photo evidence -->
<!-- Damage detail modal removed: damage reporting no longer available -->
<!-- Custom confirmation modal to replace browser confirm dialogues -->
<div id="confirmOverlay" class="modal-overlay"></div>
<div id="confirmModal" class="modal">
    <div class="modal-header">
        <h2>Konfirmasi</h2>
        <button class="modal-close" id="confirmClose">&times;</button>
    </div>
    <div class="modal-content">
        <p id="confirmMessage" style="font-size:13px;"></p>
        <div style="margin-top:20px; display:flex; justify-content:flex-end; gap:10px;">
            <button class="btn confirm-cancel-btn" id="confirmCancel">Batal</button>
            <button class="btn confirm-yes-btn" id="confirmYes">Ya</button>
        </div>
    </div>
</div>
<div id="notification" class="notification"></div>
    <div id="meterPage" class="container" style="display: none;">
        <div class="header">
            <div id="anim3" style="width:300px;height:300px;margin:auto;"></div>
            <div class="greeting" id="meterGreeting">Selamat Pagi, User!</div>
            <h1>Check Meter Air</h1>
            <div class="subtitle">Monitoring Meter Air</div>
        </div>
        <!-- Hide the original input form on the meter page.  The direct input form is no longer
             used because users will enter values directly into the table.  We keep this
             structure in the DOM but hide it so that the layout remains unaffected. -->
        <div class="card" style="display:none;">
            <form id="meterForm">
                <div class="form-group">
                    <select id="meterBlock" required>
                        <option value="">Pilih Blok...</option>
                        <option value="Induk">Induk</option>
                        <option value="Blok P">Blok P</option>
                        <option value="Blok A">Blok A</option>
                        <option value="Blok B">Blok B</option>
                        <option value="Blok C">Blok C</option>
                        <option value="Blok D">Blok D</option>
                        <option value="Blok E">Blok E</option>
                        <option value="Blok F">Blok F</option>
                        <option value="Blok G">Blok G</option>
                        <option value="Blok H">Blok H</option>
                        <option value="Blok J">Blok J</option>
                    </select>
                </div>
                <div class="form-group">
                    <select id="meterLocation" required>
                        <option value="">Pilih Lokasi...</option>
                    </select>
                </div>
                <div class="form-group">
                    <div class="input-group">
                        <input type="number" id="meterReading" placeholder="Angka Meter" step="any" required>
                        <div class="unit">m³</div>
                    </div>
                </div>
                <div class="form-group">
                    <div id="actualUsage" style="font-size: 13px; margin-top: 10px;"></div>
                </div>
                <div class="form-group">
                    <input type="text" id="meterNotes" placeholder="Catatan (Opsional)">
                </div>
                <button type="submit" class="btn" id="saveMeterButton">Simpan Meter</button>
            </form>
        </div>
        <div class="card">
            <!-- Excel-style meter sheet card -->
            <h2 style="margin-bottom: 12px; font-size: 18px; font-weight: 600;">Sheet Meter Bulanan</h2>
            <!-- Controls for the meter sheet.  Arrange all inputs and actions in a single horizontal row.
                 A hidden select stores the active block value; a labelled month picker allows the
                 user to choose a period, and action buttons live alongside it.  The block tabs
                 are moved beneath these controls so that the period and actions always remain at
                 the top of the card. -->
            <div class="filter-group sheet-controls">
                <!-- Hidden select used internally for block selection -->
                <select id="sheetBlockSelect" style="display:none;"><!-- Options will be populated dynamically --></select>
                <span class="sheet-label">Periode:</span>
                <!-- Month selector for choosing month; defaults to the current month on page load -->
                <input type="month" id="sheetMonthSelect" style="padding: 10px; border-radius: 12px; border: none; font-size: 13px; min-width: 160px;">
                <!-- Action buttons grouped together -->
                <div class="sheet-button-group">
                    <!-- PDF export button -->
                    <button id="sheetExportPdfButton" type="button" class="btn">Export PDF</button>
                    <!-- Save button persists the sheet back to Firestore -->
                    <button id="sheetSaveButton" type="button" class="btn">Simpan</button>
                </div>
                <!-- Hidden file input for future import functionality -->
                <input type="file" id="sheetPdfInput" accept="application/pdf" style="display:none;">
            </div>
            <!-- Block tabs for selecting meter block (Induk, Blok A, B, etc.) -->
            <div id="blockTabs" class="block-tabs"></div>
            <p style="font-size: 12px; opacity: 0.7; margin-bottom: 8px;">
    💡 Pilih blok dan bulan untuk menampilkan sheet. Geser ke samping untuk mengakses seluruh kolom sheet.
</p>
            <!-- Total consumption display for the month placed above the table to provide a
                 quick monthly overview before scrolling through the daily readings. -->
            <div id="totalConsumption" style="font-size: 14px; font-weight: 600; margin-bottom: 12px;"></div>
            <div class="table-container">
                <table id="sheetTable">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
    <!-- Damage reporting page removed as part of system simplification -->
<div id="estimationPage" class="container" style="display: none; padding: 20px; padding-bottom: 100px;">
  <div class="header" style="margin-bottom: 20px;">
    <div id="anim5" style="width:300px;height:300px;margin:auto;"></div>
    <div class="greeting" id="estimationGreeting" style="margin-bottom: 6px;">Selamat Pagi, User!</div>
    <h1 style="margin-bottom: 4px;">Estimasi Pemakaian Air</h1>
    <div class="subtitle">Perhitungan Manual Berdasarkan Data Bak dan Meter</div>
  </div>
  <div class="card" style="padding: 20px;">
    <form id="estimationForm">
      <div class="form-group" style="margin-bottom: 20px;">
        <label style="font-size: 14px; font-weight: 600; margin-bottom: 8px; display: block;">Data Tinggi Bak (cm)</label>
        <div class="input-group" style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
          <input type="number" id="tinggiRO" placeholder="Ketinggian Bak RO" min="0" max="300" step="1" required>
          <div class="unit">cm</div>
        </div>
        <div class="input-group" style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
          <input type="number" id="tinggiWWTP" placeholder="Ketinggian Bak WWTP" min="0" max="500" step="1" required>
          <div class="unit">cm</div>
        </div>
        <div class="input-group" style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="tinggiPDAM" placeholder="Ketinggian Bak PDAM" min="0" max="500" step="1" required>
          <div class="unit">cm</div>
        </div>
      </div>
      <div class="section-divider" style="border-top: 1px solid #eee; margin: 24px 0;"></div>
      <div class="form-group" style="margin-bottom: 20px;">
        <label style="font-size: 14px; font-weight: 600; margin-bottom: 8px; display: block;">Data Water Meter (m³)</label>
        <div class="input-group" style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
          <input type="number" id="meterStart" placeholder="Pembacaan Awal (jam lalu)" min="0" step="0.01" required>
          <div class="unit">m³</div>
        </div>
        <div class="input-group" style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
          <input type="number" id="meterEnd" placeholder="Pembacaan Akhir (sekarang)" min="0" step="0.01" required>
          <div class="unit">m³</div>
        </div>
        <div class="input-group" style="display: flex; align-items: center; gap: 8px;">
          <input type="number" id="estimationHours" placeholder="Durasi Estimasi (contoh: 4)" min="1" step="1" required>
          <div class="unit">jam</div>
        </div>
        <div class="input-group" style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
          <input type="number" id="customEstimateHour" placeholder="Estimasi ke depan (jam)" min="1" max="24" value="24" required>
          <div class="unit">jam</div>
        </div>
      </div>
      <button type="submit" class="btn" id="calculateEstimationButton" style="margin-top: 10px;">Hitung Estimasi</button>
    </form>
    <div class="estimation-result" id="estimationResult" style="display: none; margin-top: 30px;">
      <h3 style="margin-bottom: 20px;">Hasil Estimasi Pemakaian Air</h3>
      <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
        <p><strong>Konsumsi <span id="hoursUsed">0</span> Jam:</strong> <span id="consumption4h"></span> m³</p>
        <p><strong>Estimasi Pemakaian per Jam:</strong> <span id="avgPerHour"></span></p>
      </div>
      <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
        <p><strong>Proyeksi 24 Jam:</strong> <span id="projection24h"></span> m³</p>
        <p><strong>Rekomendasi:</strong> <span id="recommendation"></span></p>
        <p id="suplaiRekomendasi" style="color: red; margin-top: 15px;"></p>
      </div>
      <div id="forecastTable" style="margin-top: 25px;"></div>
      <div class="chart-container" style="margin-top: 30px;">
        <h4 style="margin-bottom: 10px;">Grafik Pemakaian Air</h4>
        <canvas id="usageChart" height="300" style="width: 100%;"></canvas>
      </div>
    </div>
  </div>
</div>
<div id="educationPage" class="container" style="display: none;">
    <div class="header">
        <div id="anim2" style="width:300px;height:300px;margin:auto;"></div>
        <div class="greeting" id="educationGreeting">Selamat Pagi, User!</div>
        <h1>Katalog Edukasi</h1>
        <div class="subtitle">Informasi dan Edukasi Sistem Air</div>
    </div>
    <div class="card">
        <div class="form-group">
            <input type="text" id="educationSearch" placeholder="Cari Konten Edukasi...">
        </div>
        <div class="form-group">
            <select id="educationCategory" required>
                <option value="">Pilih Kategori...</option>
                <option value="K3">K3</option>
                <option value="Perpipaan">Perpipaan</option>
                <option value="Mesin Hydran">Mesin Hydran</option>
                <option value="Pompa">Pompa</option>
                <option value="Jenis Jaringan">Jenis Jaringan</option>
                <option value="Jenis Valve">Jenis Valve</option>
                <option value="Jenis Hydran">Jenis Hydran</option>
                <option value="Jenis Water Meter">Jenis Water Meter</option>
                <option value="Baku Mutu Air">Baku Mutu Air</option>
                <option value="Konsumsi Harian Air">Konsumsi Harian Air</option>
                <option value="Water Treatment Plant">Water Treatment Plant</option>
            </select>
        </div>
        <div id="educationContent"></div>
    </div>
</div>
    <!-- Data management page removed.  Previously this page provided a bulk deletion function for historical data.  Individual reports can now be deleted directly from the report table, so this page is no longer needed. -->

    <!-- Analysis Page: displays aggregated charts and statistics for numeric checklist fields.
         This page helps supervisors and operators understand trends in water system
         parameters such as tank levels and meter readings.  It is hidden by default
         and shown when the corresponding nav item is selected. -->
<div id="analysisPage" class="container" style="display:none;">
    <div class="header">
        <div class="greeting" id="analysisGreeting">Selamat Pagi, User!</div>
        <!-- Animated illustration for the analysis page to emphasise data‑driven
             insights.  Loaded via Lottie and sized by the
             .analysis-animation class. -->
        <div id="analysisAnim" class="analysis-animation"></div>
        <h1>Analisis Checklist</h1>
        <div class="subtitle">Grafik dan Statistik dari Data Checklist</div>
    </div>
    <!-- A container for dynamically generated charts and summaries.  Each
         numeric field in the checklist will appear as a card with a line
         chart and summary statistics. -->
    <div id="analysisContent" class="card">
        <!--
            We provide a fallback message inside the analysis container.  This
            message is shown while the analysis data is being loaded.  If the
            analytics module fails to load (for example, due to a missing
            internet connection or a problem loading Firebase/Chart.js), the
            script that normally replaces this content will not run.  Having
            the fallback text here ensures that the page never appears
            completely blank: users will at least see a descriptive message
            explaining why the charts might not render.  When the analysis
            code runs successfully, it clears this element and populates it
            with the generated charts and statistics.
        -->
        <p id="analysisPlaceholder">Memuat analisis… Jika analisis tidak
        muncul setelah beberapa detik, periksa koneksi internet Anda atau
        pastikan modul analisis berhasil dimuat.</p>
    </div>
</div>
<script type="module">
(function() {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.documentElement.className = '';
    document.body.className = `${savedTheme}-theme`;
})();
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, collection, addDoc, getDocs, getDoc, onSnapshot, query, orderBy, serverTimestamp, where, updateDoc, doc, deleteDoc, startAfter, limit, setDoc, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getMessaging, onMessage, getToken } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";
const firebaseConfig = {
    apiKey: "AIzaSyBPmuyBT8tTr5V0yZJNbjHHLz_-iY2djpo",
    authDomain: "water-checklist.firebaseapp.com",
    projectId: "water-checklist",
    storageBucket: "water-checklist.firebasestorage.app",
    messagingSenderId: "84158811467",
    appId: "1:84158811467:web:717bd038c3da5362ad2cce"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// ---------------------------------------------------------------------
// Fallback definitions for Chart.js and Firebase Firestore APIs.
//
// When this application is used without a network connection, the external
// libraries loaded from CDNs (Chart.js and Firebase) may fail to load. If
// those globals are undefined, any subsequent references will throw
// ReferenceError and stop the execution of the entire script. To make the
// application more resilient and allow other features (such as navigation
// between pages and static content) to continue functioning, we define
// lightweight stubs. These stubs are only applied if the real APIs are not
// already defined. In the case of Chart.js, we provide a constructor that
// creates an object with `destroy` and `update` no‑op methods. For Firestore
// helpers, we return simple objects or empty snapshots so that code using
// them can still run without crashing.
if (typeof Chart === 'undefined') {
    // Define a dummy Chart constructor. It logs a warning when invoked and
    // returns an object with the minimal API used in this application.
    window.Chart = function() {
        console.warn('Chart.js tidak dimuat, menggunakan stub Chart.');
        return {
            destroy() {},
            update() {}
        };
    };
}
if (typeof getDocs !== 'function') {
    // Stub Firestore functions to return empty results. Functions such as
    // `collection`, `query`, `orderBy` and `where` simply return empty
    // objects. The `getDocs` stub returns a Promise that resolves to an
    // object containing an empty `docs` array. This allows loops over
    // snapshots to safely iterate without throwing errors.
    window.getDocs = async () => ({ docs: [] });
    window.collection = () => ({});
    window.query = () => ({});
    window.orderBy = () => ({});
    window.where = () => ({});
}
// Enable offline persistence so that attendance data entered while the network
// is unavailable will be cached in IndexedDB and restored across page
// reloads.  Without this call, writes performed offline are only kept
// in-memory and will be lost when the user refreshes the page.  See
// https://firebase.google.com/docs/firestore/manage-data/enable-offline for
// details.  Ignore any errors thrown if persistence cannot be enabled
// (e.g. in private browsing or multiple tabs).
try {
    enableIndexedDbPersistence(db);
} catch (err) {
    console.warn('Cannot enable Firestore offline persistence:', err);
}
// Initialize Firebase Storage for uploading and retrieving images
const storage = getStorage(app);
if ('serviceWorker' in navigator) {
    const swCode = `
        importScripts("https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js");
        importScripts("https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging.js");
        firebase.initializeApp(${JSON.stringify(firebaseConfig)});
        const messaging = firebase.messaging();
        messaging.onBackgroundMessage((payload) => {
            console.log("[SW] Pesan background diterima:", payload);
            const notificationTitle = payload.notification?.title || "Pesan Baru";
            const notificationOptions = {
                body: payload.notification?.body || "Anda memiliki pesan baru",
                icon: "/icons/icon-192x192.png",
                badge: "/icons/icon-72x72.png"
            };
            self.registration.showNotification(notificationTitle, notificationOptions);
        });
    `;
    const blob = new Blob([swCode], { type: 'application/javascript' });
    const swUrl = URL.createObjectURL(blob);
    navigator.serviceWorker.register(swUrl)
        .then(reg => console.log("Service Worker terdaftar:", reg))
        .catch(err => console.error("Service Worker gagal daftar:", err));
}
let messaging;
try {
    messaging = getMessaging(app);
    console.log('Firebase Messaging berhasil diinisialisasi');
    const vapidKey = 'BC_wKYhgBStBfdwVY_xkVcC4x_JpjcFbwpeWWpkgYWYScZZuEi6f296bP4CFmPxyu0AuejSxEk1OA6nGROERQhw';
    async function simpanTokenKeServer(token) {
        const userNik = localStorage.getItem("nik") || "unknown";
        await setDoc(doc(db, "deviceTokens", token), {
            token,
            userNik,
            createdAt: serverTimestamp()
        });
        console.log("Token FCM disimpan ke Firestore:", token);
    }
    async function mintaIzinNotifikasi() {
        try {
            const izin = await Notification.requestPermission();
            if (izin === 'granted') {
                const tokenFCM = await getToken(messaging, { vapidKey });
                if (tokenFCM) {
                    console.log('Token FCM:', tokenFCM);
                    await simpanTokenKeServer(tokenFCM);
                } else {
                    console.log('Tidak mendapatkan token - izin mungkin belum diberikan');
                }
            } else {
                console.log('Izin notifikasi ditolak');
            }
        } catch (err) {
            console.error('Gagal mendapatkan token:', err);
        }
    }
    onMessage(messaging, (payload) => {
        console.log('Pesan diterima (foreground):', payload);
        const judulNotif = payload.notification?.title || 'Pesan Baru';
        const isiNotif = payload.notification?.body || 'Anda memiliki pesan baru';
        tampilkanNotifikasi(`${judulNotif} - ${isiNotif}`, true);
    });
    mintaIzinNotifikasi();
} catch (error) {
    console.error('Gagal menginisialisasi Firebase Messaging:', error);
}
function tampilkanNotifikasi(pesan, isSuccess = false) {
    showNotification(pesan, isSuccess);
}
    const users = [
        { nik: 'CA00006', name: 'Muhammad Fahruroji' },
        { nik: 'CA00159', name: 'Andri Rahmatulloh' },
        { nik: 'CA00193', name: 'IIP M Ilyas' },
        { nik: 'CA00198', name: 'Shashi Prasetyo' },
        { nik: 'CA00210', name: 'Ridwan Fauzi' },
        { nik: 'CA00383', name: 'Bias Fajar Khaliq' },
        { nik: 'CA00491', name: 'Torik Hidayat' },
        { nik: 'CA00508', name: 'Amanda Lutfi' }
    ];
    let currentType = 'masuk';
    let currentNIK = '';
    let currentUserName = '';
    // Additional variables to harden the login mechanism.  We track the
    // number of consecutive failed login attempts and temporarily lock
    // the login button after too many failures.  The lockout flag
    // prevents further attempts until the timeout expires.
    let loginAttempts = 0;
    let lockout = false;
    const LOCKOUT_DURATION = 30000; // 30 seconds
    let usageChart = null;
    // Chart instance for the user activity bar chart.  Declared here so that
    // it can be destroyed and recreated whenever the analysis data is reloaded.
    let userActivityChart = null;
    const ITEMS_PER_PAGE = 10;

    
    let dashboardActivityChart = null;

    function filterStaffList() {
        const searchInput = document.getElementById('staffSearchInput');
        const query = (searchInput && searchInput.value ? searchInput.value.toLowerCase().trim() : '');
        const listEl = document.getElementById('staffList');
        if (!listEl) return;
        const items = listEl.querySelectorAll('li');
        items.forEach(li => {
            const text = li.textContent.toLowerCase();
            if (!query) {
                li.style.display = '';
            } else {
                li.style.display = text.includes(query) ? '' : 'none';
            }
        });
    }

    function setupStaffListControls() {
        const listEl = document.getElementById('staffList');
        const toggleBtn = document.getElementById('toggleStaffListBtn');
        // Only require the list and button; search and sort controls have been removed.
        if (!listEl || !toggleBtn) return;
        toggleBtn.addEventListener('click', () => {
            // Toggle the collapsed class.  When collapsed, only the first
            // five entries are visible (see CSS .staff-list.collapsed).
            listEl.classList.toggle('collapsed');
            toggleBtn.textContent = listEl.classList.contains('collapsed')
                ? 'Tampilkan Semua Staf'
                : 'Sembunyikan Sebagian';
        });
    }

    async function renderUserActivityDashboard() {
        const card = document.getElementById('userActivityCard');
        if (!card) return;
        card.style.display = 'block';
        if (dashboardActivityChart) {
            try { dashboardActivityChart.destroy(); } catch (e) {}
            dashboardActivityChart = null;
        }
        if (typeof getDocs !== 'function' || typeof collection !== 'function') {
            card.innerHTML = '<p style="font-size:12px;">Grafik aktivitas staf tidak tersedia.</p>';
            return;
        }
        // Query all checklist documents.  When offline this call returns an
        // empty snapshot.  The data will be used to compute staff metrics.
        let snap;
        try {
            snap = await getDocs(collection(db, 'checklists'));
        } catch (err) {
            console.error('Error querying user activity:', err);
            card.innerHTML = '<p style="font-size:12px;">Data aktivitas tidak dapat diambil.</p>';
            return;
        }
        // Prepare a metrics map keyed by NIK.  Initialise each user so that
        // staff with no checklist entries still appear in the summary.  Each
        // metric object tracks the number of checklists (count), the total
        // input minutes (to compute the average time), the number of
        // submissions (totalEntries) and the number of on‑time arrivals
        // (onTime).  The user name is stored for convenience.
        const metrics = {};
        if (Array.isArray(users)) {
            users.forEach(u => {
                metrics[u.nik] = {
                    name: u.name,
                    count: 0,
                    totalMinutes: 0,
                    totalEntries: 0,
                    onTime: 0
                };
            });
        }
        // Helper to parse a time string (HH:mm:ss) into minutes from midnight.
        function toMinutes(t) {
            if (!t) return null;
            const parts = t.split(':');
            if (parts.length < 2) return null;
            const hours = parseInt(parts[0], 10);
            const minutes = parseInt(parts[1], 10);
            return hours * 60 + minutes;
        }
        // Iterate over checklist documents and accumulate metrics per user.
        snap.forEach(docSnap => {
            const data = docSnap.data() || {};
            const nik = data.nik;
            if (!nik || !metrics[nik]) return;
            const m = metrics[nik];
            m.count += 1;
            m.totalEntries += 1;
            // Convert time string into minutes for averaging.  Some records may
            // omit the time; skip those in the average.  We track totalMinutes
            // separately so missing times don't skew the average.
            const tMin = toMinutes(data.time);
            if (tMin !== null) {
                m.totalMinutes += tMin;
            }
            // Determine if the entry is an on‑time arrival.  Only count
            // checklists marked as an arrival (masuk) – including custom
            // checklists with customType 'masuk'.  Use the shift definition
            // to determine the acceptable input window.  For the third
            // (night) shift, the window crosses midnight so we adjust the
            // end boundary accordingly.
            const shiftField = data.shift || '';
            const customType = data.customType || '';
            const isArrival = shiftField === 'masuk' || (shiftField === 'custom' && customType === 'masuk');
            if (isArrival && tMin !== null) {
                const shiftName = data.shiftName;
                // Find the shift definition by name.  Fallback to null if
                // unknown.
                const sh = Array.isArray(shifts) ? shifts.find(s => s.name === shiftName) : null;
                if (sh) {
                    // Parse input window boundaries.
                    const startParts = sh.startInput.split(':');
                    const endParts = sh.endInput.split(':');
                    let startMin = parseInt(startParts[0], 10) * 60 + parseInt(startParts[1], 10);
                    let endMin = parseInt(endParts[0], 10) * 60 + parseInt(endParts[1], 10);
                    let timeMin = tMin;
                    // Adjust for windows crossing midnight (e.g. shift Tiga).
                    if (endMin <= startMin) {
                        // Extend endMin into the next day.
                        endMin += 24 * 60;
                        // If the time is before the start boundary, assume it
                        // belongs to the next day and add 24h so comparisons
                        // remain consistent.
                        if (timeMin < startMin) {
                            timeMin += 24 * 60;
                        }
                    }
                    if (timeMin >= startMin && timeMin <= endMin) {
                        m.onTime += 1;
                    }
                }
            }
        });
        // Convert the metrics object into an array and compute derived
        // statistics such as the average input time and punctuality rate.  The
        // average input time is expressed in hours and minutes relative to
        // midnight for visualisation in the summary list.
        const entries = Object.keys(metrics).map(nik => {
            const m = metrics[nik];
            const avg = m.totalEntries > 0 ? m.totalMinutes / m.totalEntries : 0;
            const avgHours = Math.floor(avg / 60);
            const avgMins = Math.round(avg % 60);
            const avgStr = (isNaN(avg) || avg === 0)
                ? '-' : `${String(avgHours).padStart(2, '0')}:${String(avgMins).padStart(2, '0')}`;
            const punctuality = m.totalEntries > 0 ? (m.onTime / m.totalEntries) * 100 : 0;
            return {
                nik: nik,
                name: m.name,
                count: m.count,
                avgTimeStr: avgStr,
                onTimeRate: punctuality
            };
        });
        // Sort by number of checklist submissions descending to surface the
        // most active staff members.
        entries.sort((a, b) => b.count - a.count);

        // Populate a global map of metrics keyed by NIK.  This map allows
        // other components, such as the staff list, to display staff
        // activity information without recomputing metrics.  Each entry
        // includes the number of checklists submitted, the formatted
        // average input time and the on‑time arrival rate.
        window.userMetricsMap = {};
        entries.forEach(e => {
            window.userMetricsMap[e.nik] = e;
        });

        // If attendance data has already been loaded, refresh the staff list
        // now that updated metrics are available.  This ensures that the
        // checklist and punctuality badges appear alongside the late/early
        // counts in the staff list.
        if (typeof updateStaffListFromDocs === 'function') {
            updateStaffListFromDocs(latestAttendanceDocs);
        }
        const labels = entries.map(e => e.name);
        const counts = entries.map(e => e.count);
        // Define a colour palette to differentiate staff visually.  Repeat
        // colours if there are more staff than colours.
        const palette = ['#4CAF50','#FF9800','#2196F3','#F44336','#9C27B0','#00BCD4','#8BC34A','#FFC107','#795548','#009688','#673AB7','#E91E63'];
        const colours = entries.map((_, idx) => palette[idx % palette.length]);
        const canvas = document.getElementById('userActivityChartCanvas');
        // Remove any previous loading or placeholder nodes inside the card
        // (except our canvas and list).  Without this, offline messages from
        // previous runs would persist.
        [...card.querySelectorAll('p.temp-message')].forEach(el => el.remove());
        if (typeof Chart === 'undefined' || !canvas) {
            // Fallback when Chart.js is not available.
            const p = document.createElement('p');
            p.classList.add('temp-message');
            p.style.fontSize = '12px';
            p.style.marginTop = '8px';
            p.textContent = 'Grafik tidak tersedia.';
            card.appendChild(p);
        } else {
            const ctx = canvas.getContext('2d');
            dashboardActivityChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Jumlah Checklist',
                        data: counts,
                        backgroundColor: colours,
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                plugins: {
                        legend: {
                            // Move the legend to the right of the doughnut chart for a clearer
                            // association between colour slices and staff names.  The legend
                            // items will be arranged vertically and use small circles as
                            // markers.  Clicking a legend item still highlights the
                            // corresponding staff member in the list and toggles the slice.
                            position: 'right',
                            labels: {
                                usePointStyle: true,
                                boxWidth: 12
                            },
                            onClick: function(evt, legendItem, legend) {
                                const index = legendItem.index;
                                const nik = entries[index].nik;
                                if (typeof window.showStaffMetrics === 'function') {
                                    window.showStaffMetrics(nik);
                                }
                                const ci = legend.chart;
                                const meta = ci.getDatasetMeta(0);
                                meta.data[index].hidden = !meta.data[index].hidden;
                                ci.update();
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const idx = context.dataIndex;
                                    const e = entries[idx];
                                    return `${e.name}: ${e.count} checklist`;
                                }
                            }
                        }
                    }
                }
            });
        }
        // Populate the summary list with detailed metrics for each staff
        const topListEl = document.getElementById('topContributorList');
        if (topListEl) {
            topListEl.innerHTML = '';
            entries.forEach((entry) => {
                const li = document.createElement('li');
                li.dataset.nik = entry.nik;
                li.style.marginBottom = '4px';
                li.innerHTML = `<span style="font-weight:600;">${entry.name}</span> — ` +
                    `<span>Jumlah: <strong>${entry.count}</strong>, Rata‑rata Jam: <strong>${entry.avgTimeStr}</strong>, Ketepatan: <strong>${entry.onTimeRate.toFixed(0)}%</strong></span>`;
                topListEl.appendChild(li);
            });
        }
        // Expose a global helper to highlight a staff member in the summary
        // list when a legend item is clicked.  This function iterates
        // through all list items and applies a subtle highlight to the
        // matching NIK.
        window.showStaffMetrics = function(nik) {
            const items = document.querySelectorAll('#topContributorList li');
            items.forEach(li => {
                if (li.dataset.nik === nik) {
                    li.style.background = 'rgba(76, 175, 80, 0.15)';
                    li.style.borderRadius = '4px';
                    li.style.padding = '4px 6px';
                } else {
                    li.style.background = '';
                    li.style.borderRadius = '';
                    li.style.padding = '4px 6px';
                }
            });
        };
    }

    

    // Unsubscribe functions for Firestore listeners so we can clean up if
    // necessary (e.g. on logout).  Initially they are null.
    let attendanceDocUnsubscribe = null;
    let staffAttendanceUnsubscribe = null;

    // Keep track of the most recent attendance documents and user metrics.
    // The attendance snapshot provides late and early counts per employee,
    // while the user activity dashboard computes additional metrics such as
    // the number of checklist submissions and punctuality rate.  Storing
    // these maps globally allows the staff list to be rebuilt when either
    // dataset updates.
    let latestAttendanceDocs = [];
    window.userMetricsMap = {};

    
    function getCurrentMonthKey() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        return `${year}-${month}`;
    }

    /*
     * Update the attendance summary and progress bar UI for the current user.
     * This helper is invoked whenever the late or early counts change, either
     * via user input or via a Firestore snapshot update.  It computes the
     * total number of infractions, updates the textual summary, and draws a
     * segmented progress bar where the red segment represents late arrivals
     * and the yellow segment represents early departures.  The bar is capped
     * at 100 % when the combined total reaches the monthly limit of five.
     */
    function updateAttendanceUI(late, early) {
        const total = late + early;
        const summaryEl = document.getElementById('attendanceSummary');
        const progressBarEl = document.getElementById('attendanceProgressBar');
        const progressTextEl = document.getElementById('progressText');
        if (!summaryEl || !progressBarEl || !progressTextEl) return;
        // Display the total infractions without enforcing a hard cap.  The
        // value 5 serves as a reminder threshold only and does not
        // prevent further entries.  When the combined total exceeds 5,
        // append a gentle reminder message.
        summaryEl.innerHTML = `Telat: <strong>${late}</strong> kali, Pulang Cepat: <strong>${early}</strong> kali. Total: <strong>${total}</strong> (batas pengingat: 5)`;
        // Differentiate between hitting the threshold and exceeding it.  At exactly 5 we show a reminder message; above 5 we show a follow‑up warning.  No values are capped.
        if (total > 5) {
            summaryEl.innerHTML += '<br><span style="color:#e53935;font-weight:600;">Peringatan lanjutan: Anda telah melebihi batas pengingat 5 kali. Anda masih dapat mengisi lebih dari 5.</span>';
        } else if (total === 5) {
            summaryEl.innerHTML += '<br><span style="color:#e53935;font-weight:600;">Pengingat: Anda telah mencapai batas 5 kali. Anda masih dapat mengisi lebih dari 5.</span>';
        }
        // Compute bar width relative to maximum and build gradient segments
        const barPercent = Math.min((total / 5) * 100, 100);
        let lateSegment = 0;
        if (total > 0) {
            lateSegment = (late / total) * 100;
        }
        progressBarEl.style.width = `${barPercent}%`;
        if (total > 0) {
            progressBarEl.style.background =
                `linear-gradient(to right, #e53935 0%, #e53935 ${lateSegment}%, ` +
                `#FFCA28 ${lateSegment}%, #FFCA28 100%)`;
        } else {
            progressBarEl.style.background = '';
        }
        // Build legend for late and early counts with icons instead of coloured squares.
        const legendItems = [];
        legendItems.push(
            `<span style="display:inline-flex;align-items:center;gap:4px;"><i class="fas fa-clock" style="color:#e53935;"></i>Telat: ${late}</span>`
        );
        legendItems.push(
            `<span style="display:inline-flex;align-items:center;gap:4px;"><i class="fas fa-forward" style="color:#FFCA28;"></i>Pulang Cepat: ${early}</span>`
        );
        // Show total count and reminder threshold.  When the total
        // exceeds 5, append a reminder that the user may continue.
        legendItems.push(`<span style="font-weight:600;">Total: ${total} (batas: 5)</span>`);
        // Provide a reminder at exactly the threshold and a stronger warning beyond the threshold.
        if (total > 5) {
            legendItems.push(`<span style="color:#e53935;font-weight:600;">Peringatan lanjutan! Anda telah melebihi 5.</span>`);
        } else if (total === 5) {
            legendItems.push(`<span style="color:#e53935;font-weight:600;">Pengingat tercapai! Anda telah mencapai 5.</span>`);
        }
        progressTextEl.innerHTML = legendItems.join('');

        // Update summary card values on the attendance dashboard.  When
        // the attendance UI refreshes, reflect the latest late and early
        // counts in the top summary cards so users can see their totals
        // at a glance.
        const summaryLateEl = document.getElementById('summaryLate');
        const summaryEarlyEl = document.getElementById('summaryEarly');
        if (summaryLateEl) summaryLateEl.textContent = late;
        if (summaryEarlyEl) summaryEarlyEl.textContent = early;

    }

    /**
     * Load a daily summary of checklist and meter activities.  This function
     * queries Firestore for entries on the current date and updates the
     * list in the activity summary card on the attendance dashboard.  If
     * data cannot be loaded, the list will remain empty.  This makes the
     * dashboard more informative by offering quick insight into the volume
     * of operational tasks being recorded each day.
     */
    async function loadActivitySummary() {
        const listEl = document.getElementById('activitySummaryList');
        if (!listEl) return;
        try {
            const today = new Date();
            const formattedDate = today.toLocaleDateString('id-ID');
            let checklistCount = 0;
            // Count checklist entries for today
            try {
                const q1 = query(collection(db, 'checklists'), where('date', '==', formattedDate));
                const snap1 = await getDocs(q1);
                checklistCount = snap1.size;
            } catch (err1) {
                console.error('Error loading daily checklist summary:', err1);
            }
            // Determine the number of registered staff members from the predefined users array.
            const staffCount = Array.isArray(users) ? users.length : 0;
            // Build the summary list.  Since the meter feature has been retired, we no longer display meter counts.
            listEl.innerHTML = `
                <li><strong>Checklist Hari Ini:</strong> ${checklistCount}</li>
                <li><strong>Total Staf Terdaftar:</strong> ${staffCount}</li>
            `;
            // Also update the checklist summary card at the top of the attendance
            // dashboard.  When offline or when Firestore data is unavailable,
            // this ensures that the top summary still reflects the number of
            // checklists recorded today.
            const summaryChecklistEl = document.getElementById('summaryChecklist');
            if (summaryChecklistEl) summaryChecklistEl.textContent = checklistCount;
        } catch (error) {
            console.error('Gagal memuat ringkasan aktivitas air:', error);
        }
    }

    /**
     * Initialize the Firestore document for the current user and month.  If the
     * document does not exist, it will be created with zero counts.  This
     * function also sets up a real‑time listener on the document so that
     * updates from other clients are reflected in the UI immediately.  When
     * the input values change, the document is updated with the new counts.
     */
    async function initAttendanceDoc() {
        // Clean up any previous listener on the user's doc
        if (attendanceDocUnsubscribe) {
            attendanceDocUnsubscribe();
            attendanceDocUnsubscribe = null;
        }
        const monthKey = getCurrentMonthKey();
        // Compose a unique document ID per user per period using an
        // underscore to separate the NIK from the YYYY‑MM period.  This
        // convention matches the Firestore rule that expects IDs in the
        // format {nik}_{period}, e.g. "CA00006_2025-09".
        const docId = `${currentNIK}_${monthKey}`;
        const docRef = doc(db, 'attendance', docId);
        // Ensure the document exists (merge to avoid overwriting existing counts).
        // Use the field name "period" instead of "month" so that it passes
        // the Firestore security rules.  Include an updatedAt timestamp on
        // creation so that the document always satisfies the required
        // fields defined in the rules.
        // Ensure both "period" and legacy "month" fields are stored when
        // creating a new attendance document.  The security rules still
        // expect the field name "period", but adding the redundant
        // "month" field allows backwards compatibility with code that
        // queries on the old field.  Always merge to avoid clobbering
        // existing data.
        try {
            // Check if the document already exists.  If it does, avoid
            // resetting the late/early counts to zero when merging.  The
            // Firestore rules require these fields on creation, so we
            // include them only when creating the document.
            const existingSnap = await getDoc(docRef);
            const baseData = {
                nik: currentNIK,
                name: currentUserName,
                period: monthKey,
                month: monthKey,
                updatedAt: serverTimestamp()
            };
            if (existingSnap.exists()) {
                // Document exists; do not overwrite late/early values
                await setDoc(docRef, baseData, { merge: true });
            } else {
                // Document does not exist; initialize late/early counts
                await setDoc(docRef, {
                    ...baseData,
                    late: 0,
                    early: 0
                }, { merge: true });
            }
        } catch (err) {
            console.error('Error ensuring attendance doc:', err);
        }
        // Listen to changes in this document
        attendanceDocUnsubscribe = onSnapshot(docRef, (snap) => {
            if (!snap.exists()) return;
            const data = snap.data();
            const late = data.late || 0;
            const early = data.early || 0;
            // Update the input fields without triggering our own oninput
            const lateInput = document.getElementById('lateInput');
            const earlyInput = document.getElementById('earlyInput');
            if (lateInput) lateInput.value = late;
            if (earlyInput) earlyInput.value = early;
            updateAttendanceUI(late, early);
        });
        // Attach input handlers for the current user's attendance fields
        const lateInputEl = document.getElementById('lateInput');
        const earlyInputEl = document.getElementById('earlyInput');
        if (lateInputEl && earlyInputEl) {
            // Remove any previous listeners by cloning the nodes (simplistic approach)
            const lateClone = lateInputEl.cloneNode(true);
            const earlyClone = earlyInputEl.cloneNode(true);
            lateInputEl.parentNode.replaceChild(lateClone, lateInputEl);
            earlyInputEl.parentNode.replaceChild(earlyClone, earlyInputEl);
            /*
             * Attach new event listeners to both late and early inputs.  We
             * handle both the "input" and "change" events because some browsers
             * only fire one of them depending on how the user modifies the
             * value (typing, using the arrow spinner, or using the mobile
             * numeric keyboard).  Without listening to the "change" event the
             * value typed manually would sometimes revert back to its old
             * value because the snapshot listener overwrote it before the
             * input event handler could commit the change.  By extracting
             * the update logic into a helper function and attaching it to
             * both events we ensure user input via keyboard is persisted.
             */
            function handleLateChange() {
                let lateVal = parseInt(lateClone.value) || 0;
                let earlyVal = parseInt(earlyClone.value) || 0;
                const total = lateVal + earlyVal;
                // Issue warnings at the reminder threshold (5) and beyond.  Unlike before, we no longer cap the total; the messages simply inform the user.
                if (total === 5) {
                    showNotification('Anda telah mencapai batas pengingat 5 kali.', false);
                } else if (total > 5) {
                    showNotification('Anda telah melebihi batas pengingat 5 kali.', false);
                }
                updateDoc(docRef, {
                    late: lateVal,
                    early: earlyVal,
                    name: currentUserName,
                    nik: currentNIK,
                    period: monthKey,
                    month: monthKey,
                    updatedAt: serverTimestamp()
                });
                updateAttendanceUI(lateVal, earlyVal);
            }
            function handleEarlyChange() {
                let lateVal = parseInt(lateClone.value) || 0;
                let earlyVal = parseInt(earlyClone.value) || 0;
                const total = lateVal + earlyVal;
                // Issue warnings at the reminder threshold (5) and beyond.  We do not adjust the values.
                if (total === 5) {
                    showNotification('Anda telah mencapai batas pengingat 5 kali.', false);
                } else if (total > 5) {
                    showNotification('Anda telah melebihi batas pengingat 5 kali.', false);
                }
                updateDoc(docRef, {
                    late: lateVal,
                    early: earlyVal,
                    name: currentUserName,
                    nik: currentNIK,
                    period: monthKey,
                    month: monthKey,
                    updatedAt: serverTimestamp()
                });
                updateAttendanceUI(lateVal, earlyVal);
            }
            // Use both input and change events to capture all ways the user
            // modifies the number input.  See comment above.
            lateClone.addEventListener('input', handleLateChange);
            lateClone.addEventListener('change', handleLateChange);
            earlyClone.addEventListener('input', handleEarlyChange);
            earlyClone.addEventListener('change', handleEarlyChange);
        }
    }

    /**
     * Listen for attendance records for all staff in the current month.  This
     * function queries the `attendance` collection for documents where the
     * `month` field matches the current month.  Whenever the query result
     * changes, the staff list is rebuilt to show each employee's counts.  If
     * an employee has no record yet, they are displayed with zero counts.
     */
    function initStaffAttendanceListener() {
        // Clean up any existing listener
        if (staffAttendanceUnsubscribe) {
            staffAttendanceUnsubscribe();
            staffAttendanceUnsubscribe = null;
        }
        const monthKey = getCurrentMonthKey();
        // Query attendance documents for the current period.  Use the
        // "period" field instead of "month" to align with the Firestore
        // security rules.  Documents created before this change that
        // still use the old "month" field will not be returned by this
        // query.
        // Build a more flexible listener for attendance records.  Older
        // documents may still store the current month in a "month" field,
        // while newer ones use the "period" field.  Additionally, for
        // maximum compatibility we also inspect the document ID which
        // follows the convention `{nik}_{YYYY-MM}`.  We fetch the entire
        // attendance collection and then filter client-side to include
        // records where either the ID suffix, the period or the month
        // matches the current month key.
        const attendanceColRef = collection(db, 'attendance');
        staffAttendanceUnsubscribe = onSnapshot(attendanceColRef, (querySnap) => {
            const docs = [];
            const suffix = `_${monthKey}`;
            querySnap.forEach((docSnap) => {
                const data = docSnap.data() || {};
                const idMatch = docSnap.id.endsWith(suffix);
                const periodMatch = data.period === monthKey;
                const monthMatch = data.month === monthKey;
                if (idMatch || periodMatch || monthMatch) {
                    docs.push(data);
                }
            });
            updateStaffListFromDocs(docs);
        });
    }

    
    function updateStaffListFromDocs(attendanceDocs) {
        // Persist the latest attendance snapshot for use when metrics arrive
        latestAttendanceDocs = Array.isArray(attendanceDocs) ? attendanceDocs : latestAttendanceDocs;
        const listEl = document.getElementById('staffList');
        if (!listEl) return;
        // Clear the existing list
        listEl.innerHTML = '';
        // Build a map from NIK to attendance data for faster lookup
        const attMap = {};
        latestAttendanceDocs.forEach(d => {
            attMap[d.nik] = d;
        });
        // Always sort by name to provide a deterministic order.  The search
        // and sort inputs have been removed for simplicity, so alphabetical
        // ordering gives users a predictable list.
        const sortedUsers = [...users].sort((a, b) => a.name.localeCompare(b.name));
        // Define a colour palette to assign distinct colours to each staff member.
        const palette = ['#4CAF50','#FF9800','#2196F3','#F44336','#9C27B0','#00BCD4','#8BC34A','#FFC107','#795548','#009688','#673AB7','#E91E63'];
        sortedUsers.forEach((u, idx) => {
            const d = attMap[u.nik] || { late: 0, early: 0 };
            // Look up any computed metrics for this user.  If no metrics
            // exist yet (e.g. the user activity dashboard has not loaded),
            // default to zero values.  Count represents the number of
            // checklist submissions.
            const metrics = window.userMetricsMap && window.userMetricsMap[u.nik] ? window.userMetricsMap[u.nik] : null;
            const checklistCount = metrics ? metrics.count : 0;
            // Assign a repeatable colour based on the user index.
            const colour = palette[idx % palette.length];
            // Build the list item.  The primary row (.staff-row) uses flexbox to
            // align the coloured dot, name and badges horizontally.  A hidden
            // details section provides descriptive text when the item is
            // clicked.
            const li = document.createElement('li');
            li.innerHTML =
                `<div class="staff-row">` +
                    `<span class="staff-left" style="display:flex;align-items:center;gap:6px;">` +
                        `<span class="staff-color-dot" style="background:${colour};"></span>` +
                        // Insert a space before the NIK tag so the ID appears directly after the name with a single space of separation.
                        `<strong>${u.name}</strong> <span class="nik-tag">(${u.nik})</span>` +
                    `</span>` +
                    `<span class="attendance-count">` +
                        `<span class="late-badge">${d.late || 0}</span>` +
                        `<span class="early-badge">${d.early || 0}</span>` +
                        `<span class="checklist-badge">${checklistCount}</span>` +
                    `</span>` +
                `</div>` +
                `<div class="staff-details">Telat: ${d.late || 0} kali, Pulang Cepat: ${d.early || 0} kali, Checklist: ${checklistCount}</div>`;
            // Toggle the visibility of the details panel on click.  When clicked
            // again the panel hides.  This simple interaction provides
            // contextual information without cluttering the list.
            li.addEventListener('click', () => {
                const details = li.querySelector('.staff-details');
                if (details) {
                    details.style.display = details.style.display === 'none' || details.style.display === '' ? 'block' : 'none';
                }
            });
            listEl.appendChild(li);
        });
    }
    function renderUsageChart() {
        const meterAwal = parseFloat(document.getElementById('meterStart').value);
        const meterAkhir = parseFloat(document.getElementById('meterEnd').value);
        if (isNaN(meterAwal) || isNaN(meterAkhir)) {
            console.warn('Data meter tidak valid untuk grafik');
            return;
        }
        // Jika Chart.js tidak tersedia (misalnya ketika aplikasi berjalan tanpa koneksi internet),
        // lewati pembuatan grafik agar aplikasi tidak error.
        if (typeof Chart === 'undefined') {
            console.warn('Chart.js tidak tersedia, melewati pembuatan grafik pemakaian.');
            return;
        }
        if (usageChart) usageChart.destroy();
        const ctx = document.getElementById('usageChart').getContext('2d');
        usageChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: ['Awal', 'Sekarang'],
                datasets: [{
                    label: 'Pembacaan Meter (m³)',
                    data: [meterAwal, meterAkhir],
                    borderColor: '#4CAF50',
                    backgroundColor: 'rgba(76, 175, 80, 0.2)',
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Waktu'
                        }
                    },
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Meter (m³)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true
                    }
                }
            }
        });
    }
        const shifts = [
            // Updated shift definitions.  Check‑in windows now extend up to 60 minutes
            // after the shift start, and check‑out windows begin 40 minutes before the
            // shift end and end 30 minutes after.  The "Tiga" (third) shift crosses
            // midnight, so its endInput and endOutput values wrap accordingly.
            { name: 'Satu', start: 7, end: 15, startInput: '07:00', endInput: '08:00', startOutput: '14:20', endOutput: '15:30' },
            { name: 'Dua', start: 15, end: 23, startInput: '15:00', endInput: '16:00', startOutput: '22:20', endOutput: '23:30' },
            { name: 'Tiga', start: 23, end: 7, startInput: '23:00', endInput: '00:00', startOutput: '06:20', endOutput: '07:30' }
        ];
        const blockLocations = {
            'Induk': ['Aquaria', 'Hydran', 'Induk Blok A B C', 'Induk P+D', 'Damkar', 'Blok H', 'Blok E, F, G', 'PDAM', 'PDAM II', 'Hydrant II'],
            'Blok C': ['Toilet C11', 'Toilet C8', 'Toilet C15', 'Toilet C12', 'Toilet C17', 'Toilet C20', 'Manual 1', 'Manual 2', 'Manual 3', 'Manual 4', 'Manual 5'],
            'Blok B': ['B1 Stockfit', 'B1.2 Mesin', 'B1.3 Mesin', 'B1.4 Mesin', 'B3 Cooling Tower', 'B3.2 Mesin', 'B3.3 Mesin', 'B6.1 Toilet', 'B6.2 Toilet', 'B7.1 Toilet', 'B7.2 Toilet'],
            'Blok D': ['D1 Kantin TKA/Dapur', 'D2.1 Mess Bungalow', 'D2.2 Mess Bungalow', 'D2.3 Mess Bungalow', 'D2.6 Mess Bungalow', 'D2.7 Mess Bungalow', 'D2.8 Mess Bungalow', 'D13 Mess Bungalow', 'D3.1 Mess Bungalow', 'D3.2 Mess Bungalow', 'D4.2 Mess Bungalow', 'D5 Mess Bungalow', 'D5 Bungalow'],
            'Blok P': ['P1.1 Toilet', 'P1.2 Toilet', 'Galon', 'Send', 'Carbon', 'Sumur Bor', 'P2 Aquaria', 'P4 WWTP', 'P7 Toilet', 'P8 Office Pusat', 'P10 Kantin', 'P11.1 Toilet', 'P11.2 Kantin Dapur', 'P16 Masjid', 'P21 Damkar', 'P9', 'P17 Masjid'],
            'Blok J': ['J1 Mess Bungalow', 'J2 Mess Bungalow'],
            'Blok A': ['A10 Toilet', 'A17 Toilet', 'A14 Toilet', 'A22 Toilet', 'A19 Toilet', 'A2 Office II', 'A1 Office I', 'A5.2 Sablon', 'A5.1', 'A5 Lab', 'A23 Cooling Tower'],
            'Blok F': ['F1 Lab', 'F3.1 Toilet', 'F3.2 Toilet', 'F3.3 Toilet', 'F3.4 Toilet', 'G8.1 Toilet', 'G8.2 Toilet'],
            'Blok G': ['G12 Cooling Tower', 'G14.1 Mesin', 'G14.2 Cooling Tower', 'G15.1 Toilet', 'G15.2 Toilet'],
            'Blok H': ['H2 Masjid', 'H4 Kantin', 'H5.1 Toilet', 'H5.2 Dapur', 'H5.3 Toilet'],
            'Blok E': ['E21 Office', 'E22 Office', 'E7.1 Toilet', 'E7.2 Toilet', 'E8.1 Toilet', 'E8.2 Toilet', 'E9.1 Toilet', 'E9.2 Toilet', 'E10.3 Toilet', 'E10.4 Toilet']
        };
        function showNotification(message, isSuccess = false) {
            const notification = document.getElementById('notification');
            const statusEl = document.getElementById('inlineStatus');
            const homeBtn = document.querySelector('.back-icon');
    
            if (notification) {
                if (statusEl) statusEl.style.display = 'none';
                if (homeBtn) homeBtn.style.display = 'none';
        
                notification.textContent = message;
                notification.className = `notification ${isSuccess ? 'success' : ''}`;
                notification.style.display = 'block';
        
                setTimeout(() => {
                        notification.style.display = 'none';
                        notification.className = 'notification';
                        if (statusEl && document.getElementById("loginPage").style.display === "none") {
                            statusEl.style.display = 'inline-flex';
                        }
                        if (homeBtn && document.getElementById("loginPage").style.display !== "none") {
                            homeBtn.style.display = 'flex';
                        }
                    }, 1500);
            }
        }

    /**
     * Display a custom confirmation modal.  This function takes a message and
     * optional callbacks to execute when the user confirms or cancels the
     * action.  It shows a modal overlay with two buttons: "Ya" and
     * "Batal".  When the "Ya" button is clicked the onConfirm callback
     * runs; when the modal is closed via any other route the onCancel
     * callback runs (if provided).  This replaces native confirm() calls
     * which display the browser’s domain and are not themeable.
     *
     * @param {string} message The confirmation message to display.
     * @param {function} onConfirm Function to run when the user clicks "Ya".
     * @param {function} [onCancel] Optional function to run when the user cancels.
     */
    function showConfirm(message, onConfirm, onCancel) {
        const modal = document.getElementById('confirmModal');
        const overlay = document.getElementById('confirmOverlay');
        const msgEl = document.getElementById('confirmMessage');
        const yesBtn = document.getElementById('confirmYes');
        const cancelBtn = document.getElementById('confirmCancel');
        const closeBtn = document.getElementById('confirmClose');
        if (!modal || !overlay || !msgEl || !yesBtn || !cancelBtn) {
            // Fallback to native confirm if modal elements are missing
            const proceed = window.confirm(message);
            if (proceed && typeof onConfirm === 'function') onConfirm();
            else if (!proceed && typeof onCancel === 'function') onCancel();
            return;
        }
        msgEl.textContent = message;
        modal.style.display = 'block';
        overlay.style.display = 'block';
        // Clean up any previous handlers to avoid multiple bindings
        const cleanup = () => {
            modal.style.display = 'none';
            overlay.style.display = 'none';
            yesBtn.removeEventListener('click', confirmHandler);
            cancelBtn.removeEventListener('click', cancelHandler);
            if (closeBtn) closeBtn.removeEventListener('click', cancelHandler);
            overlay.removeEventListener('click', cancelHandler);
        };
        const confirmHandler = async () => {
            cleanup();
            if (typeof onConfirm === 'function') await onConfirm();
        };
        const cancelHandler = () => {
            cleanup();
            if (typeof onCancel === 'function') onCancel();
        };
        yesBtn.addEventListener('click', confirmHandler);
        cancelBtn.addEventListener('click', cancelHandler);
        if (closeBtn) closeBtn.addEventListener('click', cancelHandler);
        overlay.addEventListener('click', cancelHandler);
    }
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            const currentTheme = body.classList.contains('light-theme') ? 'light' : 'dark';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
            body.className = `${newTheme}-theme`;
            themeIcon.className = `fas ${newTheme === 'light' ? 'fa-moon' : 'fa-sun'}`;
            localStorage.setItem('theme', newTheme);
        }
        function switchPage(pageId) {
    
    document.querySelectorAll('#mainPage, #meterPage, #damagePage, #estimationPage, #educationPage, #attendancePage, #analysisPage')
        .forEach(page => {
            page.style.display = 'none';
            page.classList.remove('page-transition');
        });
    const targetPage = document.getElementById(pageId);
    if (targetPage) {
        targetPage.style.display = 'block';
        void targetPage.offsetWidth; 
        targetPage.classList.add('page-transition');
    }
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.toggle('active', item.dataset.page === pageId);
    });
    if (pageId === 'educationPage') {
        loadEducationContent();
    }
    // Initialise the analysis view when switching to the analysis page.  This
    // function fetches checklist data and draws charts.  It is safe to
    // call multiple times as charts are destroyed and recreated on each load.
    if (pageId === 'analysisPage') {
        loadAnalysisData();
    }
    // The data management page has been removed; no additional access control is required.
    if (pageId === 'meterPage') {
        // Only initialize the old meter report table if the elements exist (Excel-style sheet replaces it)
        const meterReportBodyEl = document.getElementById('meterReportBody');
        if (meterReportBodyEl) {
            listenMeterReports(1);
        }
        if (document.getElementById('meterFilterDate')) {
            populateMeterFilterDate();
        }
    }
    // Damage page functionality removed; no actions needed when pageId is 'damagePage'
}
function hideAllPages() {
    // Include the analysis page in the list of pages to hide.  When switching
    // views we need to ensure only the selected page is visible.  The analysis
    // page is hidden by default until selected.
    const pages = ['loginPage', 'mainPage', 'meterPage', 'damagePage', 'estimationPage', 'educationPage', 'attendancePage', 'analysisPage'];
    pages.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = 'none';
    });
}

 
function showAttendancePage() {
    hideAllPages();
    const navBar = document.getElementById('navBar');
    if (navBar) navBar.style.display = 'flex';
    const page = document.getElementById('attendancePage');
    if (page) {
        page.style.display = 'block';
        void page.offsetWidth;
        page.classList.add('page-transition');
    }
    
    document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.toggle('active', item.dataset.page === 'attendancePage');
    });
    
    populateStaffList();
    updateGreeting();
        
        loadActivitySummary();
        
        setupStaffListControls();
        
        renderUserActivityDashboard();

    // Initialise the attendance summary UI (progress bar and donut chart) when
    // entering the attendance page.  Use the current values from the late and
    // early input fields, defaulting to zero if they are unset.  Without
    // explicitly invoking updateAttendanceUI here, the doughnut chart may
    // remain blank until Firestore events or manual input occur, leaving
    // unused space at the top of the summary card.
    (function(){
        const lateEl = document.getElementById('lateInput');
        const earlyEl = document.getElementById('earlyInput');
        const lateVal = lateEl ? parseInt(lateEl.value) || 0 : 0;
        const earlyVal = earlyEl ? parseInt(earlyEl.value) || 0 : 0;
        if (typeof updateAttendanceUI === 'function') {
            updateAttendanceUI(lateVal, earlyVal);
        }
    })();
}

 
function populateStaffList() {
    const listEl = document.getElementById('staffList');
    if (!listEl) return;
    listEl.innerHTML = '';
    if (Array.isArray(users)) {
        // Always sort by name when populating the staff list.  The search
        // and sort inputs have been removed, so we default to alphabetical
        // ordering by name for a consistent display.
        const sorted = [...users].sort((a, b) => a.name.localeCompare(b.name));
        sorted.forEach(u => {
            const li = document.createElement('li');
            // Add a space before the NIK tag so the ID sits right after the name with minimal spacing
            li.innerHTML = `<strong>${u.name}</strong> <span class="nik-tag">(${u.nik})</span>`;
            listEl.appendChild(li);
        });
    }
}
function login() {
    // Fetch the NIK and name entered by the user.  Trim and normalise the
    // values so that comparison against the registered user list is case
    // insensitive for the name and always uppercase for the NIK.
    const nikInputEl = document.getElementById('nikInput');
    const nameInputEl = document.getElementById('nameInput');
    const nikValue = nikInputEl.value.trim().toUpperCase();
    const nameValue = nameInputEl ? nameInputEl.value.trim() : '';
    const button = document.getElementById('loginButton');
    const overlay = document.getElementById('loginOverlay');
    // Require both the NIK and the name to be filled out.  This prevents
    // accidental submission and ensures that we can properly verify the
    // credentials against our registered user list.
    if (!nikValue || !nameValue) {
        showNotification('Mohon masukkan NIK dan nama terlebih dahulu!');
        return;
    }
    // Validate the NIK format (two letters "CA" followed by five digits).  If it
    // does not match the expected pattern, reject the attempt immediately.
    const nikPattern = /^CA\d{5}$/;
    if (!nikPattern.test(nikValue)) {
        showNotification('Format NIK tidak valid! Gunakan format CA00000.');
        return;
    }
    // If the user is in a lockout period due to excessive failed attempts,
    // block this attempt and advise the user to wait.  The lockout flag
    // and timer are defined alongside other globals.
    if (lockout) {
        showNotification('Terlalu banyak percobaan. Silakan coba lagi nanti.');
        return;
    }
    // Find a matching user by NIK and name.  The NIK is compared exactly
    // (case‑insensitive by virtue of being converted to upper case), while
    // the name comparison ignores letter casing to accommodate minor
    // differences in capitalisation.
    const user = users.find(u => u.nik.toUpperCase() === nikValue && u.name.toLowerCase() === nameValue.toLowerCase());
    if (user) {
        // Indicate that the login process is underway and block multiple
        // submissions by showing a loading spinner and overlay.  After a
        // short delay, the success animation is displayed and the main
        // application pages are initialised for the authenticated user.
        button.classList.add('loading');
        overlay.style.display = 'block';
        setTimeout(() => {
            button.classList.remove('loading');
            showSuccessAnimation(() => {
                overlay.style.display = 'none';
                // Clear the input fields after a successful login
                nikInputEl.value = '';
                if (nameInputEl) nameInputEl.value = '';
                // Store the current user credentials for later use in the app
                currentNIK = nikValue;
                currentUserName = user.name;
                // Reveal the attendance toggle once the user logs in so they can
                // access the dashboard later
                const attendanceToggle = document.getElementById('attendanceToggle');
                if (attendanceToggle) {
                    attendanceToggle.style.display = 'flex';
                    // Bind click handler here to ensure it works in all environments
                    attendanceToggle.onclick = showAttendancePage;
                }
                // After successful login, show the attendance dashboard first
                // instead of the checklist.  Then initialise the attendance
                // Firestore listeners.  These functions subscribe to both the
                // current user's document and the collection for all staff.
                showAttendancePage();
                initAttendanceDoc();
                initStaffAttendanceListener();
                // Prepare other parts of the application in the background
                updateShiftInfo();
                populateFilters();
                listenReports(1);
            });
        }, 700);
    } else {
        // Increment the failed attempt counter.  When the user exceeds
        // the allowed threshold (3 attempts), disable the login button
        // temporarily and set a lockout flag.  After the lockout
        // duration, re‑enable the button and reset the counter.  This
        // discourages brute‑force attempts against the local user list.
        loginAttempts++;
        if (loginAttempts >= 3) {
            lockout = true;
            button.disabled = true;
            showNotification('Terlalu banyak percobaan. Coba lagi dalam 30 detik.');
            setTimeout(() => {
                lockout = false;
                loginAttempts = 0;
                button.disabled = false;
            }, LOCKOUT_DURATION);
        } else {
            // Provide a generic failure message without revealing which
            // credential was incorrect.
            showNotification('NIK atau nama tidak terdaftar!');
        }
    }
}
        function updateGreeting() {
            const now = new Date();
            const hour = now.getHours();
            let greetingText = '';
            if ((hour >= 19 && hour <= 23) || (hour >= 0 && hour < 5)) {
                greetingText = `Selamat Malam, ${currentUserName}!`;
            } else if (hour >= 5 && hour < 8) {
                greetingText = `Selamat Pagi, ${currentUserName}!`;
            } else if (hour >= 8 && hour < 17) {
                greetingText = `Selamat Siang, ${currentUserName}!`;
            } else {
                greetingText = `Selamat Sore, ${currentUserName}!`;
            }
            document.getElementById('greeting').textContent = greetingText;
            // Update greeting across all pages that display the time‑of‑day greeting,
            // including the newly added analysis page.  Each element is updated
            // if it exists in the DOM.  Keeping all IDs in one array makes
            // extending the list straightforward.
            ['meterGreeting', 'damageGreeting', 'estimationGreeting', 'educationGreeting', 'dataManagementGreeting', 'attendanceGreeting', 'analysisGreeting'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = greetingText;
            });
        }
        function updateShiftInfo() {
            const now = new Date();
            const hour = now.getHours();
            let shiftInfo = 'Di luar jam shift';
            shifts.forEach(shift => {
                if (hour >= shift.start || (shift.start > shift.end && hour < shift.end)) {
                    shiftInfo = `${shift.name} (${shift.startInput}-${shift.endOutput})`;
                }
            });
            document.getElementById('shiftInfo').textContent = shiftInfo;
        }
        function updateTime() {
            /*
             * Format the current time manually to avoid locale-specific separators.  Using
             * toLocaleTimeString('id-ID') sometimes produces values with dot (.) separators
             * or fails to update in some environments, leading to "00:00:00" being shown
             * consistently.  By constructing the time string manually we ensure a
             * consistent HH:MM:SS format and correct updating every second.
             */
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('currentTime').textContent = `${hours}:${minutes}:${seconds}`;
            updateShiftInfo();
            updateGreeting();
        }
        function switchType(type) {
            currentType = type;
            document.querySelectorAll('.switch-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`switch${type.charAt(0).toUpperCase() + type.slice(1)}`).classList.add('active');
            const saveButton = document.getElementById('saveChecklistButton');
            saveButton.textContent = 'Simpan Checklist';
            delete saveButton.dataset.editId;
            document.getElementById('checklistForm').reset();
    // Show or hide the custom shift/type selectors based on the selected checklist type.
    const customOptsEl = document.getElementById('customOptions');
    if (customOptsEl) {
        customOptsEl.style.display = type === 'custom' ? 'block' : 'none';
    }
        }
        function showEditForm(checklist) {
            if (checklist.nik !== currentNIK) {
                showNotification('Anda tidak memiliki izin untuk mengedit laporan ini.');
                return;
            }
            currentType = checklist.shift || 'custom';
            document.querySelectorAll('.switch-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`switch${currentType.charAt(0).toUpperCase() + currentType.slice(1)}`).classList.add('active');
            // Toggle visibility of custom shift/type selectors and populate values when editing.
            const customOptsEl = document.getElementById('customOptions');
            const customShiftSel = document.getElementById('customShiftSelect');
            const customTypeSel = document.getElementById('customTypeSelect');
            if (customOptsEl && customShiftSel && customTypeSel) {
                if (checklist.shift === 'custom') {
                    customOptsEl.style.display = 'block';
                    customShiftSel.value = checklist.shiftName || '';
                    customTypeSel.value = checklist.customType || '';
                } else {
                    customOptsEl.style.display = 'none';
                    customShiftSel.value = '';
                    customTypeSel.value = '';
                }
            }
            document.getElementById('bakRO').value = checklist.bakRO || '';
            document.getElementById('tinggiRO').value = checklist.tinggiRO || '';
            document.getElementById('bakWWTP').value = checklist.bakWWTP || '';
            document.getElementById('tinggiWWTP').value = checklist.tinggiWWTP || '';
            document.getElementById('pompa').value = checklist.pompa || '';
            document.getElementById('tinggiPDAM').value = checklist.tinggiPDAM || '';
            document.getElementById('statusPDAM').value = checklist.statusPDAM || '';
            document.getElementById('hydrantStatus').value = checklist.hydrantStatus || '';
            document.getElementById('AStatus').value = checklist.AStatus || '';
            document.getElementById('EStatus').value = checklist.EStatus || '';
            document.getElementById('damkar').value = checklist.damkar || '';
            document.getElementById('supplyPDAM').value = checklist.supplyPDAM || '';
            document.getElementById('meterIndukPDAM').value = checklist.meterIndukPDAM || '';
            document.getElementById('meterIndukWTP').value = checklist.meterIndukWTP || '';
            document.getElementById('PDAM').value = checklist.PDAM || '';
            document.getElementById('flowPDAM').value = checklist.flowPDAM || '';
            document.getElementById('catatan').value = checklist.catatan || '';
            const saveButton = document.getElementById('saveChecklistButton');
            saveButton.textContent = 'Update Checklist';
            saveButton.dataset.editId = checklist.id;
            document.getElementById('checklistFormContainer').scrollIntoView({ behavior: 'smooth' });
        }
        async function saveChecklist(event) {
            event.preventDefault();
            const saveButton = document.getElementById('saveChecklistButton');
            saveButton.classList.add('loading');
            const now = new Date();
            const hour = now.getHours();
            const minute = now.getMinutes();
            const dateStr = now.toLocaleDateString('id-ID');
            let currentShift = null;
            if (currentType !== 'custom') {
                shifts.forEach(shift => {
                    if (hour >= shift.start || (shift.start > shift.end && hour < shift.end)) {
                        currentShift = shift;
                    }
                });
            }
            if (currentType !== 'custom' && !currentShift) {
                showNotification('Checklist masuk/pulang hanya dapat dilakukan selama jam shift!');
                saveButton.classList.remove('loading');
                return;
            }
            // When using the standard masuk/pulang modes, validate that the current time
            // falls within the allowed window.  Convert times to absolute minutes since
            // midnight to handle both normal and cross‑midnight ranges.  For custom
            // checklists the time window validation is skipped.
            let selectedCustomShift = '';
            let selectedCustomType = '';
            if (currentType !== 'custom') {
                const [sInputH, sInputM] = currentShift.startInput.split(':').map(Number);
                const [eInputH, eInputM] = currentShift.endInput.split(':').map(Number);
                const [sOutputH, sOutputM] = currentShift.startOutput.split(':').map(Number);
                const [eOutputH, eOutputM] = currentShift.endOutput.split(':').map(Number);
                const startInputMin = sInputH * 60 + sInputM;
                const endInputMin = eInputH * 60 + eInputM;
                const startOutputMin = sOutputH * 60 + sOutputM;
                const endOutputMin = eOutputH * 60 + eOutputM;
                const currentMin = hour * 60 + minute;
                const isMasukWindow =
                    currentType === 'masuk' &&
                    (startInputMin <= endInputMin
                        ? currentMin >= startInputMin && currentMin <= endInputMin
                        : currentMin >= startInputMin || currentMin <= endInputMin);
                const isPulangWindow =
                    currentType === 'pulang' &&
                    (startOutputMin <= endOutputMin
                        ? currentMin >= startOutputMin && currentMin <= endOutputMin
                        : currentMin >= startOutputMin || currentMin <= endOutputMin);
                if (!isMasukWindow && !isPulangWindow) {
                    showNotification(
                        `Checklist ${currentType} untuk ${currentShift.name} hanya dapat dilakukan pada ` +
                            (currentType === 'masuk'
                                ? `${currentShift.startInput}-${currentShift.endInput}`
                                : `${currentShift.startOutput}-${currentShift.endOutput}`) +
                            `. Silakan coba lagi pada waktu yang sesuai.`
                    );
                    saveButton.classList.remove('loading');
                    return;
                }
            } else {
                // Require the user to choose both a shift and a type (masuk/pulang) for
                // custom checklists.  These selections are used later when storing
                // additional metadata on the document.
                const cs = document.getElementById('customShiftSelect');
                const ct = document.getElementById('customTypeSelect');
                selectedCustomShift = cs ? cs.value : '';
                selectedCustomType = ct ? ct.value : '';
                if (!selectedCustomShift || !selectedCustomType) {
                    showNotification('Mohon pilih shift dan tipe untuk custom checklist!');
                    saveButton.classList.remove('loading');
                    return;
                }
            }
            const user = users.find(u => u.nik === currentNIK);
            // Build the checklist document.  For custom entries, set the shift to
            // "custom", attach the selected shift name and type, and leave the
            // standard shiftName field equal to the chosen shift.  For masuk/pulang
            // entries, use the current shift name from the schedule definitions.
            const data = {
                nik: currentNIK,
                name: user ? user.name : 'Unknown',
                date: dateStr,
                time: now.toLocaleTimeString('id-ID'),
                shift: currentType === 'custom' ? 'custom' : currentType,
                shiftName:
                    currentType === 'custom'
                        ? selectedCustomShift
                        : currentShift
                        ? currentShift.name
                        : 'Unknown',
                bakRO: document.getElementById('bakRO').value,
                tinggiRO: parseFloat(document.getElementById('tinggiRO').value) || 0,
                bakWWTP: document.getElementById('bakWWTP').value,
                tinggiWWTP: parseFloat(document.getElementById('tinggiWWTP').value) || 0,
                pompa: document.getElementById('pompa').value,
                tinggiPDAM: parseFloat(document.getElementById('tinggiPDAM').value) || 0,
                statusPDAM: document.getElementById('statusPDAM').value,
                hydrantStatus: document.getElementById('hydrantStatus').value,
                AStatus: document.getElementById('AStatus').value,
                EStatus: document.getElementById('EStatus').value,
                damkar: document.getElementById('damkar').value,
                supplyPDAM: document.getElementById('supplyPDAM').value,
                meterIndukPDAM: parseFloat(document.getElementById('meterIndukPDAM').value) || 0,
                meterIndukWTP: parseFloat(document.getElementById('meterIndukWTP').value) || 0,
                PDAM: parseFloat(document.getElementById('PDAM').value) || 0,
                flowPDAM: parseFloat(document.getElementById('flowPDAM').value) || 0,
                catatan: document.getElementById('catatan').value || '',
                createdAt: serverTimestamp()
            };
            // Attach the custom type only when using a custom checklist.  This field
            // identifies whether the custom entry corresponds to a "Masuk" or "Pulang"
            // operation and is displayed in the reports.
            if (currentType === 'custom') {
                data.customType = selectedCustomType;
            }
            const required = ['bakRO', 'tinggiRO', 'bakWWTP', 'tinggiWWTP', 'pompa', 'tinggiPDAM', 'statusPDAM', 'hydrantStatus', 'AStatus', 'EStatus', 'damkar', 'supplyPDAM', 'meterIndukPDAM', 'meterIndukWTP', 'PDAM', 'flowPDAM'];
            const missing = required.filter(field => !data[field] && data[field] !== 0);
            if (missing.length > 0) {
                showNotification('Mohon lengkapi semua field yang wajib diisi!');
                saveButton.classList.remove('loading');
                return;
            }
            try {
                if (saveButton.dataset.editId) {
                    await updateDoc(doc(db, 'checklists', saveButton.dataset.editId), data);
                    showNotification('Checklist berhasil diperbarui!', true);
                    saveButton.textContent = 'Simpan Checklist';
                    delete saveButton.dataset.editId;
                } else {
                    await addDoc(collection(db, 'checklists'), data);
                    showNotification('Checklist berhasil disimpan!', true);
                }
                document.getElementById('checklistForm').reset();
            } catch (error) {
                console.error('Gagal menyimpan checklist:', error);
                showNotification(`Gagal menyimpan checklist: ${error.message}`);
            } finally {
                saveButton.classList.remove('loading');
            }
        }
        async function getLastVisibleDoc(collectionName, page, limit) {
            try {
                const q = query(collection(db, collectionName), orderBy('createdAt', 'desc'), limit(limit * (page - 1)));
                const snapshot = await getDocs(q);
                return snapshot.docs[snapshot.docs.length - 1];
            } catch (error) {
                console.error(`Error getting last visible doc for ${collectionName}:`, error);
                showNotification(`Gagal memuat dokumen terakhir untuk ${collectionName}.`);
                return null;
            }
        }
        async function listenReports(page = 1) {
    const filterDate = document.getElementById('filterDate').value;
    const filterShift = document.getElementById('filterShift').value;
    const filterNIK = document.getElementById('filterNIK').value;
    const reportBody = document.getElementById('reportBody');
    const pagination = document.getElementById('reportPagination');
    let q = query(collection(db, 'checklists'), orderBy('createdAt', 'desc'), limit(ITEMS_PER_PAGE));
    if (page > 1) {
        const lastVisible = await getLastVisibleDoc('checklists', page, ITEMS_PER_PAGE);
        if (lastVisible) {
            q = query(q, startAfter(lastVisible));
        }
    }
    if (filterDate) q = query(q, where('date', '==', filterDate));
    if (filterShift) q = query(q, where('shift', '==', filterShift));
    if (filterNIK) q = query(q, where('nik', '==', filterNIK));
    try {
        onSnapshot(q, async (snapshot) => {
            reportBody.innerHTML = '';
            const checklists = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            if (checklists.length === 0) {
                // There are no checklist entries.  Show a message spanning four columns
                // since the notes column has been removed from the table.
                reportBody.innerHTML = '<tr><td colspan="4">Tidak ada data checklist.</td></tr>';
            } else {
                checklists.forEach(c => {
                    const dataRow = document.createElement('tr');
                    // Render the basic data columns.  For the shift column, if the entry
                    // is a custom checklist then append both the selected shift name and
                    // the custom type (Masuk/Pulang) in parentheses.  Otherwise display
                    // the shift name only when it is not "Custom".  This ensures that
                    // custom entries are clearly labelled for easy identification.
                    // Build the checklist row without displaying the “catatan” field.  Notes are now
                    // only visible in the detail view, so this table shows a concise overview.
                    dataRow.innerHTML = `
                        <td>${c.date || '-'}</td>
                        <td>${c.time || '-'}</td>
                        <td>${
                            c.shift ? c.shift.toUpperCase() : '-'
                        } ${
                            c.shift === 'custom'
                                ? '(' +
                                  (c.shiftName || '-') +
                                  (c.customType
                                      ? ', ' +
                                        (c.customType.charAt(0).toUpperCase() + c.customType.slice(1))
                                      : '') +
                                  ')'
                                : c.shiftName && c.shiftName !== 'Custom'
                                ? '(' + (c.shiftName || '-') + ')'
                                : ''
                        }</td>
                        <!-- Display name first and show NIK in parentheses for a neater presentation -->
                        <td>${c.name || '-'} (${c.nik || '-'})</td>
                    `;
                    reportBody.appendChild(dataRow);
                    const actionRow = document.createElement('tr');
                    actionRow.classList.add('action-row');
                    // Render actions across individual cells to align with their respective columns.
                    actionRow.innerHTML = `
                        <td>
                            <button class="detail-btn" data-detail='${JSON.stringify(c).replace(/'/g, "&apos;")}'>
                                <i class="fas fa-eye"></i> Detail
                            </button>
                        </td>
                        <td>
                            <button class="share-btn whatsapp-btn" data-detail='${JSON.stringify(c).replace(/'/g, "&apos;")}'>
                                <i class="fas fa-share-alt"></i> Share
                            </button>
                        </td>
                        <td>
                            <button class="edit-btn" data-detail='${JSON.stringify(c).replace(/'/g, "&apos;")}' ${c.nik !== currentNIK ? 'disabled' : ''}>
                                <i class="fas fa-edit"></i> Edit
                            </button>
                        </td>
                        <td>
                            <button class="delete-btn" data-detail='${JSON.stringify(c).replace(/'/g, "&apos;")}'>
                                <i class="fas fa-trash"></i> Hapus
                            </button>
                        </td>
                    `;
                    reportBody.appendChild(actionRow);
                });
            }
            const totalDocs = (await getDocs(query(collection(db, 'checklists')))).size;
            pagination.innerHTML = `
                <button onclick="listenReports(${page - 1})" ${page === 1 ? 'disabled' : ''}>Sebelumnya</button>
                <span>Halaman ${page}</span>
                <button onclick="listenReports(${page + 1})" ${page * ITEMS_PER_PAGE >= totalDocs ? 'disabled' : ''}>Selanjutnya</button>
            `;
        }, (error) => {
            console.error('Error in listenReports:', error);
            showNotification(`Gagal memuat laporan checklist: ${error.message}`);
        });
    } catch (error) {
        console.error('Error setting up checklist listener:', error);
        showNotification(`Gagal mengatur listener checklist: ${error.message}`);
    }
}
        async function populateFilters() {
            console.log('Populating checklist filters...');
            try {
                const filterDate = document.getElementById('filterDate');
                const filterNIK = document.getElementById('filterNIK');
                const snapshot = await getDocs(query(collection(db, 'checklists'), orderBy('date', 'desc')));
                const checklists = snapshot.docs.map(doc => doc.data());
                console.log('Checklist dates:', checklists.map(c => c.date));
                const dates = [...new Set(checklists.map(c => c.date))].sort((a, b) => new Date(b) - new Date(a));
                // Build NIK options showing the user's name first with the NIK in parentheses.  This makes the dropdown easier to scan.
                const nikOptions = users.map(u => `<option value="${u.nik}">${u.name} (${u.nik})</option>`);
                filterDate.innerHTML = '<option value="">Semua Tanggal</option>' + dates.map(d => `<option value="${d}">${d}</option>`).join('');
                filterNIK.innerHTML = '<option value="">Semua Pengguna</option>' + nikOptions.join('');
            } catch (error) {
                console.error('Error populating checklist filters:', error);
                showNotification(`Gagal memuat filter checklist: ${error.message}`);
            }
        }
        function showDetail(data) {
            const modal = document.getElementById('detailModal');
            const modalContent = document.getElementById('modalContent');
            const modalOverlay = document.getElementById('modalOverlay');
            modalContent.innerHTML = `
                <ul>
                    <li><strong>Tanggal:</strong> ${data.date || '-'}</li>
                    <li><strong>Waktu:</strong> ${data.time || '-'}</li>
                    <li><strong>Shift:</strong> ${
                        data.shift ? data.shift.toUpperCase() : '-'
                    } ${
                        data.shift === 'custom'
                            ? '(' +
                              (data.shiftName || '-') +
                              (data.customType
                                  ? ', ' +
                                    (data.customType.charAt(0).toUpperCase() + data.customType.slice(1))
                                  : '') +
                              ')'
                            : data.shiftName && data.shiftName !== 'Custom'
                            ? '(' + (data.shiftName || '-') + ')'
                            : ''
                    }</li>
                    <!-- Show the staff member's name followed by their NIK in parentheses -->
                    <li><strong>Penginput:</strong> ${data.name || '-'} (${data.nik || '-'})</li>
                    <li><strong>Bak Distribusi RO:</strong> ${data.bakRO || '-'} (Ketinggian: ${data.tinggiRO || 0} cm)</li>
                    <li><strong>Bak Tampung WWTP:</strong> ${data.bakWWTP || '-'} (Ketinggian: ${data.tinggiWWTP || 0} cm)</li>
                    <li><strong>Pompa Transfer:</strong> ${data.pompa || '-'}</li>
                    <li><strong>Bak Input PDAM:</strong> ${data.statusPDAM || '-'} (Ketinggian: ${data.tinggiPDAM || 0} cm)</li>
                    <li><strong>Hydrant Status:</strong> ${data.hydrantStatus || '-'}</li>
                    <li><strong>Supply Air Blok A:</strong> ${data.AStatus || '-'}</li>
                    <li><strong>Supply Air Blok E:</strong> ${data.EStatus || '-'}</li>
                    <li><strong>Supply Air Blok Damkar:</strong> ${data.damkar || '-'}</li>
                    <li><strong>Supply Air PDAM:</strong> ${data.supplyPDAM || '-'}</li>
                    <li><strong>Meter Induk PDAM:</strong> ${data.meterIndukPDAM || 0} m³</li>
                    <li><strong>Meter Induk WTP:</strong> ${data.meterIndukWTP || 0} m³</li>
                    <li><strong>Flow Input PDAM:</strong> ${data.PDAM || 0} m³</li>
                    <li><strong>Flow Rate PDAM:</strong> ${data.flowPDAM || 0} m³/j</li>
                    <li><strong>Catatan:</strong> ${data.catatan || '-'}</li>
                </ul>
            `;
            modal.style.display = 'block';
            modalOverlay.style.display = 'block';
        }
        function closeModal() {
            // Hide both checklist and damage detail modals when overlay is clicked
            document.getElementById('detailModal').style.display = 'none';
            const dmgModal = document.getElementById('damageDetailModal');
            if (dmgModal) dmgModal.style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
        }
        function shareChecklist(data) {
    const message = `
• Laporan Checklist
• Tanggal: ${data.date || '-'}
• Waktu: ${data.time || '-'}
• Shift: ${
    data.shift ? data.shift.toUpperCase() : '-'
} ${
    data.shift === 'custom'
        ? '(' +
          (data.shiftName || '-') +
          (data.customType
              ? ', ' +
                (data.customType.charAt(0).toUpperCase() + data.customType.slice(1))
              : '') +
          ')'
        : data.shiftName && data.shiftName !== 'Custom'
        ? '(' + (data.shiftName || '-') + ')'
        : ''
}
• Penginput: ${data.name || '-'} (${data.nik || '-'})
1. Bak Distribusi RO: ${data.bakRO || '-'} (Ketinggian: ${data.tinggiRO || 0} cm)
2. Bak Tampung WWTP: ${data.bakWWTP || '-'} (Ketinggian: ${data.tinggiWWTP || 0} cm)
3. Pompa Transfer: ${data.pompa || '-'}
4. Bak Input PDAM: ${data.statusPDAM || '-'} (Ketinggian: ${data.tinggiPDAM || 0} cm)
5. Hydrant Status: ${data.hydrantStatus || '-'}
6. Supply Air Blok A: ${data.AStatus || '-'}
7. Supply Air Blok E: ${data.EStatus || '-'}
8. Supply Air Damkar: ${data.damkar || '-'}
9. Supply Air PDAM: ${data.supplyPDAM || '-'}
10. Meter Induk PDAM: ${data.meterIndukPDAM || 0} m³
11. Meter Induk WTP: ${data.meterIndukWTP || 0} m³
12. Flow Input PDAM: ${data.PDAM || 0} m³
13. Flow Rate PDAM: ${data.flowPDAM || 0} m³/j
Catatan: ${data.catatan || '-'}
    `.trim();
    const encodedMessage = encodeURIComponent(message);
    const whatsappUrl = `https://wa.me/?text=${encodedMessage}`;
    window.open(whatsappUrl, '_blank');
}
async function saveMeter(event) {
    event.preventDefault();
    const saveButton = document.getElementById('saveMeterButton');
    saveButton.classList.add('loading');
    const now = new Date();
    const data = {
        nik: currentNIK,
        name: currentUserName,
        date: now.toLocaleDateString('id-ID'),
        time: now.toLocaleTimeString('id-ID'),
        block: document.getElementById('meterBlock').value,
        location: document.getElementById('meterLocation').value,
        meterReading: parseFloat(document.getElementById('meterReading').value) || 0,
        notes: document.getElementById('meterNotes').value || '',
        createdAt: serverTimestamp()
    };
    try {
        console.log('Menyimpan data meter:', data);
        await addDoc(collection(db, 'meters'), data);
        showNotification('Data meter berhasil disimpan!', true);
        document.getElementById('meterForm').reset();
        document.getElementById('actualUsage').innerHTML = '';
        listenMeterReports(1);
    } catch (error) {
        console.error('Gagal menyimpan data meter:', error);
        showNotification(`Gagal menyimpan data meter: ${error.message}`);
    } finally {
        saveButton.classList.remove('loading');
    }
}
async function saveDamage(event) {
    event.preventDefault();
    const saveButton = document.getElementById('saveDamageButton');
    saveButton.classList.add('loading');
    try {
        // Determine if we are editing an existing report or creating a new one
        const editId = saveButton.dataset.editId;
        // Get selected files from both capture and upload inputs
        const captureFile = document.getElementById('damagePhoto').files[0];
        const uploadFile = document.getElementById('damageUpload').files[0];
        // Prefer the uploaded file if present; otherwise use the captured image
        const originalFile = uploadFile || captureFile;
        // Validate the file type. Only image files are allowed for upload. If the
        // provided file is not an image or no file is selected, `file` remains null.
        // For now, we skip compression and use the original file directly. Compression
        // can introduce errors for certain image formats and is unnecessary during
        // initial testing. If compression is desired later, it can be re-enabled.
        let file = null;
        if (originalFile && originalFile.type && originalFile.type.startsWith('image/')) {
            file = originalFile;
        }
        if (editId) {
            // Editing existing report
            const docRef = doc(db, 'damages', editId);
            const updateData = {
                damageType: document.getElementById('damageType').value,
                block: document.getElementById('damageBlock').value,
                location: document.getElementById('damageLocation').value,
                specific: document.getElementById('damageSpecific').value,
                notes: document.getElementById('damageNotes').value || ''
            };
            console.log('Memperbarui data kerusakan:', updateData);
            await updateDoc(docRef, updateData);
            // If a new file is selected, upload it and update photoUrl
            if (file) {
                // Use the compressed file name to avoid storing large files
                const storageRef = ref(storage, `damageImages/${editId}/${file.name}`);
                await uploadBytes(storageRef, file);
                const downloadURL = await getDownloadURL(storageRef);
                await updateDoc(docRef, { photoUrl: downloadURL });
            }
            showNotification('Laporan kerusakan berhasil diperbarui!', true);
        } else {
            // Creating new report
            const now = new Date();
            const newData = {
                nik: currentNIK,
                name: currentUserName,
                date: now.toLocaleDateString('id-ID'),
                time: now.toLocaleTimeString('id-ID'),
                damageType: document.getElementById('damageType').value,
                block: document.getElementById('damageBlock').value,
                location: document.getElementById('damageLocation').value,
                specific: document.getElementById('damageSpecific').value,
                notes: document.getElementById('damageNotes').value || '',
                createdAt: serverTimestamp()
            };
            console.log('Menyimpan data kerusakan baru:', newData);
            const docRef = await addDoc(collection(db, 'damages'), newData);
            // Upload the photo if provided
            if (file) {
                const storageRef = ref(storage, `damageImages/${docRef.id}/${file.name}`);
                await uploadBytes(storageRef, file);
                const downloadURL = await getDownloadURL(storageRef);
                await updateDoc(docRef, { photoUrl: downloadURL });
            }
            showNotification('Laporan kerusakan berhasil disimpan!', true);
        }
        // Reset form and preview
        document.getElementById('damageForm').reset();
        document.getElementById('damageImagePreview').innerHTML = '';
        // Remove any edit indicators and restore button text
        delete saveButton.dataset.editId;
        saveButton.textContent = 'Simpan Laporan';
        // Refresh the list
        listenDamageReports(1);
    } catch (error) {
        console.error('Gagal menyimpan laporan kerusakan:', error);
        showNotification(`Gagal menyimpan laporan kerusakan: ${error.message}`);
    } finally {
        saveButton.classList.remove('loading');
    }
}
async function calculateActualUsage(block, location, currentReading) {
    try {
        console.log('Mencari data untuk:', {block, location}); 
        const q = query(
            collection(db, 'meters'),
            where('block', '>=', block),
            where('block', '<=', block + '\uf8ff'), 
            orderBy('createdAt', 'desc'),
            limit(1)
        );
        const snapshot = await getDocs(q);
        console.log('Data ditemukan:', snapshot.docs.length); 
        if (!snapshot.empty) {
            const allData = snapshot.docs.map(doc => doc.data());
            const prevData = allData.find(data => 
                data.location.toLowerCase() === location.toLowerCase()
            );
            if (prevData) {
                console.log('Data sebelumnya ditemukan:', prevData); 
                const prevReading = parseFloat(prevData.meterReading) || 0;
                return currentReading - prevReading;
            }
        }
        console.log('Tidak ada data sebelumnya yang cocok'); 
        return null;
    } catch (error) {
        console.error('Error dalam calculateActualUsage:', error);
        return null;
    }
}
document.addEventListener('DOMContentLoaded', () => {
    const meterReadingInput = document.getElementById('meterReading');
    if (!meterReadingInput) return;
    meterReadingInput.addEventListener('input', async () => {
        const block = document.getElementById('meterBlock').value;
        const location = document.getElementById('meterLocation').value;
        const reading = parseFloat(meterReadingInput.value);
        if (block && location && !isNaN(reading)) {
            const actual = await calculateActualUsage(block, location, reading);
            const el = document.getElementById('actualUsage');
            if (actual !== null) {
                el.innerHTML = `<strong>Pemakaian Aktual:</strong> ${actual.toFixed(2)} m³`;
            } else {
                el.innerHTML = `<em>Belum ada data sebelumnya untuk ${block} - ${location}</em>`;
            }
        } else {
            document.getElementById('actualUsage').innerHTML = '';
        }
    });
});
async function listenMeterReports(page = 1) {
    const filterBlock = document.getElementById('meterFilterBlock').value;
    const filterDate = document.getElementById('meterFilterDate').value;
    const reportBody = document.getElementById('meterReportBody');
    const pagination = document.getElementById('meterPagination');
    let q = query(collection(db, 'meters'), orderBy('createdAt', 'desc'), limit(ITEMS_PER_PAGE));
    if (page > 1) {
        try {
            const lastVisible = await getLastVisibleDoc('meters', page, ITEMS_PER_PAGE);
            if (lastVisible) {
                q = query(q, startAfter(lastVisible));
            }
        } catch (error) {
            console.error('Error getting last visible doc for meters:', error);
            showNotification('Gagal memuat dokumen terakhir untuk meter.');
            return;
        }
    }
    if (filterBlock) q = query(q, where('block', '==', filterBlock));
    if (filterDate) q = query(q, where('date', '==', filterDate));
        try {
        onSnapshot(q, async (snapshot) => {
            reportBody.innerHTML = '';
            const meters = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            if (meters.length === 0) {
                reportBody.innerHTML = '<tr><td colspan="8">Tidak ada data meter.</td></tr>';
            } else {
                const allMeters = await getDocs(collection(db, 'meters'));
                const allMeterData = allMeters.docs.map(doc => doc.data());
                for (const m of meters) {
                    const previousReadings = allMeterData
                        .filter(item => 
                            item.block === m.block && 
                            item.location === m.location && 
                            item.date <= m.date && 
                            item.time < m.time
                        )
                        .sort((a, b) => 
                            new Date(`${b.date} ${b.time}`) - new Date(`${a.date} ${a.time}`)
                        );
                    const previousReading = previousReadings[0];
                    const actualUsage = previousReading ? 
                        (m.meterReading - previousReading.meterReading).toFixed(2) : 
                        '-';
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${m.date || '-'}</td>
                        <td>${m.time || '-'}</td>
                        <td>${m.block || '-'}</td>
                        <td>${m.location || '-'}</td>
                        <td>${m.meterReading || 0} m³</td>
                        <td>${actualUsage !== '-' ? actualUsage + ' m³' : '-'}</td>
                        <td>${m.notes || '-'}</td>
                        <td><button class="whatsapp-btn" data-detail='${JSON.stringify(m)}'><i class="fab fa-whatsapp"></i> Share</button></td>
                    `;
                    reportBody.appendChild(row);
                }
            }
            const totalDocs = (await getDocs(query(collection(db, 'meters')))).size;
            pagination.innerHTML = `
                <button onclick="listenMeterReports(${page - 1})" ${page === 1 ? 'disabled' : ''}>Sebelumnya</button>
                <span>Halaman ${page}</span>
                <button onclick="listenMeterReports(${page + 1})" ${page * ITEMS_PER_PAGE >= totalDocs ? 'disabled' : ''}>Selanjutnya</button>
            `;
        }, (error) => {
            console.error('Error in listenMeterReports:', error);
            showNotification(`Gagal memuat laporan meter: ${error.message}`);
        });
    } catch (error) {
        console.error('Error setting up meter listener:', error);
        showNotification(`Gagal mengatur listener meter: ${error.message}`);
    }
}
async function listenDamageReports(page = 1) {
    const filterBlock = document.getElementById('damageFilterBlock').value;
    const filterDate = document.getElementById('damageFilterDate').value;
    const reportBody = document.getElementById('damageReportBody');
    const pagination = document.getElementById('damagePagination');
    let q = query(collection(db, 'damages'), orderBy('createdAt', 'desc'), limit(ITEMS_PER_PAGE));
    if (page > 1) {
        try {
            const lastVisible = await getLastVisibleDoc('damages', page, ITEMS_PER_PAGE);
            if (lastVisible) {
                q = query(q, startAfter(lastVisible));
            }
        } catch (error) {
            console.error('Error getting last visible doc for damages:', error);
            showNotification('Gagal memuat dokumen terakhir untuk kerusakan.');
            return;
        }
    }
    if (filterBlock) q = query(q, where('block', '==', filterBlock));
    if (filterDate) q = query(q, where('date', '==', filterDate));
    try {
        onSnapshot(q, async (snapshot) => {
            console.log('Damage snapshot:', snapshot.docs.map(doc => doc.data()));
            reportBody.innerHTML = '';
            const damages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            if (damages.length === 0) {
                console.log('No damage data found for current filters');
                reportBody.innerHTML = '<tr><td colspan="7">Tidak ada data kerusakan.</td></tr>';
            } else {
                damages.forEach(d => {
                    const row = document.createElement('tr');
                    // Prepare the JSON string for data-detail, escape single quotes for HTML
                    // Serialize the damage data to a JSON string and escape double quotes
                    // for safe embedding into an HTML attribute. Double quotes are converted
                    // to the HTML entity &quot; so that JSON can be stored in a data attribute
                    // enclosed with double quotes without breaking the markup. Single quotes
                    // remain untouched since they do not interfere with double-quoted
                    // attributes.
                    const detailStr = JSON.stringify(d).replace(/"/g, '&quot;');
                    row.innerHTML = `
                        <td>${d.date || '-'}</td>
                        <td>${d.damageType || '-'}</td>
                        <td>${d.block || '-'}</td>
                        <td>${d.location || '-'}</td>
                        <td>${d.specific || '-'}</td>
                        <td>${d.notes || '-'}</td>
                        <td style="white-space: nowrap; display:flex; gap:4px; justify-content:center;">
                            <button class="preview-btn" data-detail="${detailStr}" title="Preview"><i class="fa fa-eye"></i></button>
                            <button class="edit-damage-btn" data-detail="${detailStr}" title="Edit"><i class="fa fa-edit"></i></button>
                            <button class="whatsapp-btn" data-detail="${detailStr}" title="Share"><i class="fab fa-whatsapp"></i></button>
                        </td>
                    `;
                    reportBody.appendChild(row);
                });
            }
            const totalDocs = (await getDocs(query(collection(db, 'damages')))).size;
            pagination.innerHTML = `
                <button onclick="listenDamageReports(${page - 1})" ${page === 1 ? 'disabled' : ''}>Sebelumnya</button>
                <span>Halaman ${page}</span>
                <button onclick="listenDamageReports(${page + 1})" ${page * ITEMS_PER_PAGE >= totalDocs ? 'disabled' : ''}>Selanjutnya</button>
            `;
        }, (error) => {
            console.error('Error in listenDamageReports:', error);
            showNotification(`Gagal memuat laporan kerusakan: ${error.message}`);
        });
    } catch (error) {
        console.error('Error setting up damage listener:', error);
        showNotification(`Gagal mengatur listener kerusakan: ${error.message}`);
    }
}
async function populateMeterFilterDate() {
    console.log('Populating meter filter date...');
    try {
        const filterDate = document.getElementById('meterFilterDate');
        // Skip populating if the meter filter element does not exist (Excel-style sheet mode)
        if (!filterDate) return;
        const snapshot = await getDocs(query(collection(db, 'meters'), orderBy('date', 'desc')));
        const meters = snapshot.docs.map(doc => doc.data());
        console.log('Meter dates:', meters.map(m => m.date));
        const dates = [...new Set(meters.map(m => m.date))].sort((a, b) => new Date(b) - new Date(a));
        filterDate.innerHTML = '<option value="">Semua Tanggal</option>' + dates.map(d => `<option value="${d}">${d}</option>`).join('');
    } catch (error) {
        console.error('Error populating meter filter date:', error);
        showNotification(`Gagal memuat filter tanggal meter: ${error.message}`);
    }
}
async function populateDamageFilterDate() {
    console.log('Populating damage filter date...');
    try {
        const filterDate = document.getElementById('damageFilterDate');
        const snapshot = await getDocs(query(collection(db, 'damages'), orderBy('date', 'desc')));
        const damages = snapshot.docs.map(doc => doc.data());
        console.log('Damage dates:', damages.map(d => d.date));
        const dates = [...new Set(damages.map(d => d.date))].sort((a, b) => new Date(b) - new Date(a));
        filterDate.innerHTML = '<option value="">Semua Tanggal</option>' + dates.map(d => `<option value="${d}">${d}</option>`).join('');
    } catch (error) {
        console.error('Error populating damage filter date:', error);
        showNotification(`Gagal memuat filter tanggal kerusakan: ${error.message}`);
    }
}
function populateMeterFilterBlock() {
    const filterBlock = document.getElementById('meterFilterBlock');
    // Skip if the filter element does not exist (Excel-style sheet mode)
    if (!filterBlock) return;
    filterBlock.innerHTML = '<option value="">Semua Blok</option>' + Object.keys(blockLocations).map(block => `<option value="${block}">${block}</option>`).join('');
}
function populateDamageFilterBlock() {
    const filterBlock = document.getElementById('damageFilterBlock');
    filterBlock.innerHTML = '<option value="">Semua Blok</option>' + Object.keys(blockLocations).map(block => `<option value="${block}">${block}</option>`).join('');
}
function populateLocations(selectId, block) {
    const select = document.getElementById(selectId);
    select.innerHTML = '<option value="">Pilih Lokasi...</option>';
    if (block && blockLocations[block]) {
        select.innerHTML += blockLocations[block].map(loc => `<option value="${loc}">${loc}</option>`).join('');
    }
}

// === Damage reporting utilities ===
// Display the details of a damage report along with its photo evidence in a modal
function showDamageDetail(data) {
    const modal = document.getElementById('damageDetailModal');
    const modalContent = document.getElementById('damageDetailContent');
    const modalOverlay = document.getElementById('modalOverlay');
    if (!modal || !modalContent) return;
    // Construct list of report details
    const detailList = `
        <ul>
            <li><strong>Tanggal:</strong> ${data.date || '-'}</li>
            <li><strong>Jenis Kerusakan:</strong> ${data.damageType || '-'}</li>
            <li><strong>Blok:</strong> ${data.block || '-'}</li>
            <li><strong>Lokasi:</strong> ${data.location || '-'}</li>
            <li><strong>Spesifik:</strong> ${data.specific || '-'}</li>
            <li><strong>Catatan:</strong> ${data.notes || '-'}</li>
        </ul>
    `;
    const imageHtml = data.photoUrl
        ? `<div style="margin-top: 12px; text-align:center;"><img src="${data.photoUrl}" alt="Bukti Kerusakan" style="max-width: 100%; border-radius: 8px;" /></div>`
        : `<p style="margin-top: 12px;"><em>Tidak ada foto bukti</em></p>`;
    modalContent.innerHTML = detailList + imageHtml;
    modal.style.display = 'block';
    modalOverlay.style.display = 'block';
}

// Populate the damage form with existing data for editing
function showDamageEditForm(damage) {
    // Only allow editing if the current user created the report
    if (damage.nik && damage.nik !== currentNIK) {
        showNotification('Anda tidak memiliki izin untuk mengedit laporan ini.');
        return;
    }
    // Set the form fields based on the damage data
    document.getElementById('damageType').value = damage.damageType || '';
    document.getElementById('damageBlock').value = damage.block || '';
    // Ensure location options correspond to the selected block
    populateLocations('damageLocation', damage.block);
    document.getElementById('damageLocation').value = damage.location || '';
    document.getElementById('damageSpecific').value = damage.specific || '';
    document.getElementById('damageNotes').value = damage.notes || '';
    // Show existing photo preview if available
    const preview = document.getElementById('damageImagePreview');
    if (damage.photoUrl) {
        preview.innerHTML = `<img src="${damage.photoUrl}" alt="Foto Kerusakan" style="max-width: 100%; border-radius: 8px;" />`;
    } else {
        preview.innerHTML = '';
    }
    // Change save button text and set edit identifier
    const saveBtn = document.getElementById('saveDamageButton');
    saveBtn.textContent = 'Update Laporan';
    saveBtn.dataset.editId = damage.id;
    // Scroll the user to the damage form for editing
    document.getElementById('damageForm').scrollIntoView({ behavior: 'smooth' });
}

// Show a preview of the selected damage image (capture or upload)
function updateDamageImagePreview(inputEl) {
    const preview = document.getElementById('damageImagePreview');
    const file = inputEl.files && inputEl.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            preview.innerHTML = `<img src="${e.target.result}" alt="Preview Foto" style="max-width: 100%; border-radius: 8px;" />`;
        };
        reader.readAsDataURL(file);
    } else {
        preview.innerHTML = '';
    }
}

// Update the associated label text to reflect the selected file name.  If no
// file is selected, it restores the label to its default text stored in
// `data-default-text`.  This helper keeps the UI responsive when users
// choose or remove files for upload or capture.
function updateFileLabel(inputEl) {
    const label = document.querySelector(`label[for="${inputEl.id}"]`);
    if (!label) return;
    const span = label.querySelector('span');
    if (!span) return;
    if (inputEl.files && inputEl.files.length > 0) {
        span.textContent = inputEl.files[0].name;
    } else {
        span.textContent = label.dataset.defaultText || span.textContent;
    }
}

// Compress an image file to reduce its size before uploading.
// This function resizes the image to fit within a maximum width/height while
// maintaining the aspect ratio and reduces the JPEG quality. If the provided
// file is not an image, the original file is returned. The returned object
// is a new File instance with a `.jpg` extension.
async function compressImage(file, maxWidth = 1024, maxHeight = 1024, quality = 0.8) {
    // If there is no file or the file is not an image, return it unchanged
    if (!file || !file.type || !file.type.startsWith('image/')) {
        return file;
    }
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            let width = img.width;
            let height = img.height;
            // Scale the image to fit within the specified dimensions while preserving aspect ratio
            if (width > height) {
                if (width > maxWidth) {
                    height *= maxWidth / width;
                    width = maxWidth;
                }
            } else {
                if (height > maxHeight) {
                    width *= maxHeight / height;
                    height = maxHeight;
                }
            }
            const canvas = document.createElement('canvas');
            canvas.width = Math.round(width);
            canvas.height = Math.round(height);
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            canvas.toBlob((blob) => {
                if (!blob) {
                    // Fallback to original file if compression fails
                    resolve(file);
                    return;
                }
                // Create a new File object with a .jpg extension to ensure JPEG format
                const newFileName = file.name.replace(/\.[^.]+$/i, '') + '.jpg';
                const compressedFile = new File([blob], newFileName, { type: 'image/jpeg' });
                resolve(compressedFile);
            }, 'image/jpeg', quality);
        };
        img.onerror = (err) => {
            console.error('Error loading image for compression:', err);
            resolve(file);
        };
        // Use URL.createObjectURL to load the image
        img.src = URL.createObjectURL(file);
    });
}
function hitungVolumeBak(tinggiCm, panjang, lebar, tinggiMax) {
    const tinggiM = tinggiCm / 100;
    return panjang * lebar * Math.min(tinggiM, tinggiMax); 
}
async function calculateEstimation(event) {
    event.preventDefault();
    const button = document.getElementById('calculateEstimationButton');
    button.classList.add('loading');
    try {
        const tinggiRO = parseFloat(document.getElementById('tinggiRO').value) || 0;
        const tinggiWWTP = parseFloat(document.getElementById('tinggiWWTP').value) || 0;
        const tinggiPDAM = parseFloat(document.getElementById('tinggiPDAM').value) || 0;
        const meterStart = parseFloat(document.getElementById('meterStart').value) || 0;
        const meterEnd = parseFloat(document.getElementById('meterEnd').value) || 0;
        const estimationHours = parseFloat(document.getElementById('estimationHours').value) || 0;
        const customHours = parseFloat(document.getElementById('customEstimateHour').value) || 24;
        if (tinggiRO > 300 || tinggiWWTP > 500 || tinggiPDAM > 500) {
            showNotification('Tinggi salah satu bak melebihi batas maksimal!');
            return;
        }
        if (meterEnd <= meterStart) {
            showNotification('Pembacaan akhir harus lebih besar dari pembacaan awal!');
            return;
        }
        if (estimationHours <= 0) {
            showNotification('Durasi estimasi harus lebih dari 0!');
            return;
        }
        const consumption = meterEnd - meterStart;
        const avgPerHour = consumption / estimationHours;
        // Taksiran min/max sebagai rentang ±5%
        const avgMin = avgPerHour * 0.95;
        const avgMax = avgPerHour * 1.05;
        // Definisi dimensi bak (m)
        const BAK_RO = { panjang: 3, lebar: 5, tinggi: 3, jumlah: 2 };
        const BAK_WWTP = { panjang: 12, lebar: 20, tinggi: 5 };
        const BAK_PDAM = { panjang: 12, lebar: 20, tinggi: 5 };
        // Hitung volume aktual berdasarkan tinggi bak (cm -> m)
        const volumeRO = hitungVolumeBak(tinggiRO, BAK_RO.panjang, BAK_RO.lebar, BAK_RO.tinggi) * BAK_RO.jumlah;
        const volumeWWTP = hitungVolumeBak(tinggiWWTP, BAK_WWTP.panjang, BAK_WWTP.lebar, BAK_WWTP.tinggi);
        const volumePDAM = hitungVolumeBak(tinggiPDAM, BAK_PDAM.panjang, BAK_PDAM.lebar, BAK_PDAM.tinggi);
        // Hitung kapasitas maksimum masing-masing bak
        const maxVolumeRO = BAK_RO.panjang * BAK_RO.lebar * BAK_RO.tinggi * BAK_RO.jumlah;
        const maxVolumeWWTP = BAK_WWTP.panjang * BAK_WWTP.lebar * BAK_WWTP.tinggi;
        const maxVolumePDAM = BAK_PDAM.panjang * BAK_PDAM.lebar * BAK_PDAM.tinggi;
        const totalVolume = volumeRO + volumeWWTP + volumePDAM;
        const maxTotalVolume = maxVolumeRO + maxVolumeWWTP + maxVolumePDAM;
        // Persentase ketinggian terhadap kapasitas maksimum
        const percentRO = (volumeRO / maxVolumeRO) * 100;
        const percentWWTP = (volumeWWTP / maxVolumeWWTP) * 100;
        const percentPDAM = (volumePDAM / maxVolumePDAM) * 100;
        // Proyeksi konsumsi
        const projection24h = avgPerHour * 24;
        const customProjection = avgPerHour * customHours;
        // Estimasi lama suplai habis
        const hoursUntilEmpty = avgPerHour > 0 ? totalVolume / avgPerHour : Infinity;
        // Rekomendasi konsumsi berdasarkan kapasitas
        let recommendation = 'Pemakaian dalam batas wajar.';
        // Jika proyeksi 24 jam melebihi 80% suplai tersedia, peringatkan konsumsi tinggi
        if (projection24h > totalVolume * 0.8) {
            recommendation = 'Pemakaian tinggi, awasi suplai dan kurangi penggunaan.';
        } else if (projection24h < totalVolume * 0.1) {
            recommendation = 'Pemakaian rendah, tetap hemat.';
        }
        // Rekomendasi suplai dan lama suplai
        let suplaiNote = '';
        if (hoursUntilEmpty < customHours) {
            suplaiNote = `PERINGATAN: Suplai air tersisa sekitar ${hoursUntilEmpty.toFixed(1)} jam, kurang dari estimasi ${customHours} jam. Tambahkan suplai atau kurangi konsumsi.`;
        } else {
            suplaiNote = `Suplai air cukup untuk ${customHours} jam ke depan.`;
        }
        // Tampilkan hasil
        document.getElementById('hoursUsed').textContent = estimationHours;
        document.getElementById('consumption4h').textContent = consumption.toFixed(2);
        document.getElementById('avgPerHour').textContent = `${avgMin.toFixed(2)} – ${avgMax.toFixed(2)} m³/jam`;
        document.getElementById('projection24h').textContent = projection24h.toFixed(2);
        // Tambahkan informasi konsumsi per orang berdasarkan pedoman WHO (15–20 L/orang/hari ≈ 0.0006–0.0008 m³/jam per orang)
        const whoMin = (15 / 1000) / 24;
        const whoMax = (20 / 1000) / 24;
        document.getElementById('recommendation').textContent = `${recommendation} (Pedoman WHO: 15–20 L/orang/hari ≈ ${whoMin.toFixed(4)}–${whoMax.toFixed(4)} m³/jam per orang)`;
        document.getElementById('suplaiRekomendasi').textContent = suplaiNote;
        document.getElementById('estimationResult').style.display = 'block';
        // Tabel proyeksi
        const forecastDurations = [4, 8, 12, 24];
        let forecastHTML = `<table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
        <thead><tr style="background: #f1f1f1;">
        <th style="padding: 8px;">Proyeksi</th>
        <th style="padding: 8px;">Estimasi Pemakaian (m³)</th>
        <th style="padding: 8px;">Prediksi Meter (m³)</th>
        <th style="padding: 8px;">Sisa Suplai (jam)</th></tr></thead><tbody>`;
        forecastDurations.forEach(hours => {
            const usage = avgPerHour * hours;
            const predictedMeter = meterEnd + usage;
            const remainingHours = avgPerHour > 0 ? (totalVolume - usage) / avgPerHour : Infinity;
            forecastHTML += `<tr><td style="padding: 6px;">${hours} jam ke depan</td>
            <td style="padding: 6px;">${usage.toFixed(2)}</td>
            <td style="padding: 6px;">${predictedMeter.toFixed(2)}</td>
            <td style="padding: 6px;">${remainingHours.toFixed(1)}</td></tr>`;
        });
        forecastHTML += '</tbody></table>';
        document.getElementById('forecastTable').innerHTML = forecastHTML;
    } catch (error) {
        console.error('Gagal menghitung estimasi:', error);
        showNotification(`Gagal menghitung estimasi: ${error.message}`);
    } finally {
        button.classList.remove('loading');
    }
        // Periksa ketersediaan Chart.js sebelum membuat grafik.  Jika Chart.js tidak dimuat
        // (misalnya karena koneksi internet terputus) maka skip pembuatan grafik agar tidak terjadi error.
        if (typeof Chart !== 'undefined') {
            if (usageChart) usageChart.destroy();
            const ctx = document.getElementById('usageChart').getContext('2d');
            usageChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Awal', 'Sekarang'],
                    datasets: [{
                        label: 'Angka Meter (m³)',
                        data: [meterStart, meterEnd],
                        borderColor: '#4CAF50',
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Waktu' } },
                        y: { title: { display: true, text: 'Meter (m³)' } }
                    }
                }
            });
            // Panggil ulang renderUsageChart untuk memastikan grafik diperbarui
            renderUsageChart();
        } else {
            console.warn('Chart.js tidak tersedia, melewati pembuatan grafik estimasi.');
        }
}
function loadEducationContent() {
    const search = document.getElementById('educationSearch').value.toLowerCase();
    const category = document.getElementById('educationCategory').value;
    const contentDiv = document.getElementById('educationContent');
    const educationData = {
        K3: [
            {
                title: 'Prosedur Keselamatan Kerja di WTP',
                content: `
                    <p>Prosedur keselamatan kerja di Water Treatment Plant (WTP) sangat penting untuk mencegah kecelakaan dan memastikan operasi yang aman. Berikut adalah langkah-langkah utama:</p>
                    <ul>
                        <li><strong>Penggunaan APD:</strong> Selalu gunakan helm keselamatan (SNI 1039:2016), sepatu safety, sarung tangan tahan air, dan kacamata pelindung saat melakukan inspeksi atau pemeliharaan peralatan seperti pompa, valve, dan hydran.</li>
                        <li><strong>Pemeriksaan Awal:</strong> Lakukan pengecekan terhadap potensi bahaya seperti kebocoran gas, tekanan tinggi (>10 bar), atau permukaan licin sebelum memulai pekerjaan.</li>
                        <li><strong>Lockout-Tagout (LOTO):</strong> Terapkan prosedur LOTO untuk mengisolasi peralatan listrik atau hidrolik selama pemeliharaan. Pastikan semua pekerja mengetahui status peralatan melalui tag yang jelas.</li>
                        <li><strong>Pelatihan Rutin:</strong> Lakukan pelatihan K3 setiap 6 bulan untuk memastikan pemahaman terhadap risiko spesifik di WTP, seperti paparan bahan kimia atau kebocoran pipa.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Sebelum memeriksa pompa transfer, pastikan pompa dalam status OFF dan pasang tag LOTO untuk mencegah aktivasi tak sengaja.</p>
                `
            },
            {
                title: 'Penanganan Darurat Kebocoran',
                content: `
                    <p>Kebocoran pipa atau hydran dapat menyebabkan kehilangan air yang signifikan dan risiko keselamatan. Berikut adalah SOP penanganan darurat:</p>
                    <ol>
                        <li><strong>Identifikasi Kebocoran:</strong> Gunakan alat deteksi kebocoran (misalnya, akustik leak detector) untuk menentukan lokasi kebocoran dengan akurat.</li>
                        <li><strong>Isolasi Aliran:</strong> Matikan valve terdekat (gate valve atau ball valve) untuk menghentikan aliran air ke area kebocoran.</li>
                        <li><strong>Pengamanan Area:</strong> Pasang tanda peringatan dan batasi akses ke area kebocoran untuk mencegah kecelakaan.</li>
                        <li><strong>Laporan:</strong> Laporkan kejadian ke supervisor melalui sistem pelaporan digital (misalnya, aplikasi ini) dan sertakan detail lokasi, jenis kebocoran, dan dampaknya.</li>
                        <li><strong>Perbaikan Sementara:</strong> Gunakan clamp pipa atau sealant untuk menutup kebocoran sementara sebelum perbaikan permanen.</li>
                    </ol>
                    <p><strong>Contoh Kasus:</strong> Kebocoran pada pipa HDPE di Blok A dapat menyebabkan kehilangan air 0.5 m³/jam. Dengan isolasi cepat, kehilangan dapat dikurangi hingga perbaikan selesai dalam 2 jam.</p>
                `
            },
            {
                title: 'Pemantauan Lingkungan Kerja',
                content: `
                    <p>Pemantauan lingkungan kerja di WTP bertujuan untuk memastikan kondisi operasional yang aman dan efisien. Parameter yang perlu dipantau meliputi:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Standar Aman</th>
                                <th>Alat Ukur</th>
                                <th>Frekuensi</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Suhu</td>
                                <td>20-30°C</td>
                                <td>Termometer Digital</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>Kelembapan</td>
                                <td>40-60%</td>
                                <td>Higrometer</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>Kebisingan</td>
                                <td>< 85 dB</td>
                                <td>Sound Level Meter</td>
                                <td>Mingguan</td>
                            </tr>
                            <tr>
                                <td>Ventilasi</td>
                                <td>Udara segar > 10 m³/menit</td>
                                <td>Anemometer</td>
                                <td>Mingguan</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Metode Monitoring:</strong> Gunakan sensor IoT untuk pemantauan real-time dan catat data dalam checklist harian untuk analisis tren lingkungan kerja.</p>
                    <p><strong>Risiko:</strong> Suhu tinggi (>30°C) dapat menyebabkan overheating pompa, sedangkan kelembapan rendah (<40%) meningkatkan risiko korosi pada pipa.</p>
                `
            }
        ],
        'Perpipaan': [
            {
                title: 'Jenis Pipa dan Spesifikasi Teknis',
                content: `
                    <p>Pipa merupakan komponen utama dalam sistem distribusi air di WTP. Berikut adalah jenis pipa yang umum digunakan beserta spesifikasi teknisnya:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Jenis Pipa</th>
                                <th>Material</th>
                                <th>Tekanan Maksimum</th>
                                <th>Kegunaan</th>
                                <th>Kelebihan</th>
                                <th>Kekurangan</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>PVC</td>
                                <td>Polyvinyl Chloride</td>
                                <td>10 bar</td>
                                <td>Distribusi air bersih</td>
                                <td>Ringan, tahan korosi</td>
                                <td>Rentan terhadap suhu tinggi</td>
                            </tr>
                            <tr>
                                <td>HDPE</td>
                                <td>High-Density Polyethylene</td>
                                <td>16 bar</td>
                                <td>Distribusi air WWTP/PDAM</td>
                                <td>Fleksibel, tahan tekanan</td>
                                <td>Biaya awal tinggi</td>
                            </tr>
                            <tr>
                                <td>Stainless Steel</td>
                                <td>Baja Tahan Karat</td>
                                <td>25 bar</td>
                                <td>Air bertekanan tinggi</td>
                                <td>Tahan korosi, kuat</td>
                                <td>Berat, mahal</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Pemilihan Pipa:</strong> Pilih pipa berdasarkan tekanan operasional (gunakan pressure gauge untuk verifikasi) dan jenis air (misalnya, air WWTP membutuhkan pipa tahan korosi seperti HDPE).</p>
                    <p><strong>Standar:</strong> Pastikan pipa memenuhi SNI 0068:2015 untuk pipa air minum.</p>
                `
            },
            {
                title: 'Pemeliharaan dan Inspeksi Pipa',
                content: `
                    <p>Pemeliharaan pipa diperlukan untuk mencegah kebocoran, korosi, dan penurunan efisiensi sistem. Berikut adalah prosedur pemeliharaan:</p>
                    <ul>
                        <li><strong>Inspeksi Visual:</strong> Periksa pipa setiap minggu untuk mendeteksi tanda-tanda korosi, retak, atau kebocoran pada sambungan.</li>
                        <li><strong>Pengukuran Tekanan:</strong> Gunakan pressure gauge untuk memastikan tekanan pipa berada dalam batas aman (biasanya 2-10 bar, tergantung jenis pipa).</li>
                        <li><strong>Pembersihan:</strong> Lakukan flushing pipa setiap 3 bulan untuk menghilangkan endapan yang dapat menyebabkan penyumbatan.</li>
                        <li><strong>Penggantian Komponen:</strong> Ganti seal atau sambungan yang aus setiap 1-2 tahun, tergantung pada frekuensi penggunaan.</li>
                    </ul>
                    <p><strong>Alat Bantu:</strong> Gunakan alat deteksi kebocoran berbasis akustik atau kamera inspeksi untuk memeriksa pipa bawah tanah.</p>
                    <p><strong>Contoh Aplikasi:</strong> Pada pipa HDPE di Blok C, inspeksi mingguan mengidentifikasi kebocoran kecil yang menyebabkan kehilangan air 0.2 m³/hari, yang diperbaiki dengan clamp pipa dalam waktu 1 jam.</p>
                `
            },
            {
                title: 'Estimasi Kehilangan Air di Pipa',
                content: `
                    <p>Kehilangan air akibat kebocoran adalah masalah umum dalam sistem distribusi. Berikut adalah metode untuk menghitung dan meminimalkan kehilangan air:</p>
                    <ul>
                        <li><strong>Rumus Kehilangan Air:</strong> Kehilangan (%) = [(Meter Induk - Total Meter Distribusi) / Meter Induk] × 100.</li>
                        <li><strong>Langkah Perhitungan:</strong>
                            <ol>
                                <li>Catat pembacaan meter induk PDAM (misalnya, 1000 m³).</li>
                                <li>Jumlahkan pembacaan meter distribusi di semua blok (misalnya, 950 m³).</li>
                                <li>Hitung kehilangan: [(1000 - 950) / 1000] × 100 = 5%.</li>
                            </ol>
                        </li>
                        <li><strong>Analisis Penyebab:</strong> Kebocoran dapat disebabkan oleh sambungan longgar, korosi, atau tekanan berlebih. Gunakan data historis dari laporan kerusakan untuk mengidentifikasi pola.</li>
                        <li><strong>Pencegahan:</strong> Pasang sensor tekanan dan flow meter untuk mendeteksi anomali aliran secara real-time.</li>
                    </ul>
                    <p><strong>Contoh Kasus:</strong> Kehilangan air 5% di Blok A menunjukkan adanya kebocoran pada sambungan pipa PVC. Setelah perbaikan, kehilangan turun menjadi <1%.</p>
                    <p><strong>Standar:</strong> Menurut ISO 24512:2007, kehilangan air di sistem distribusi idealnya <10%.</p>
                `
            }
        ],
        'Mesin Hydran': [
            {
                title: 'Fungsi dan Spesifikasi Mesin Hydran',
                content: `
                    <p>Mesin hydran adalah komponen kritis untuk menyediakan air bertekanan tinggi, terutama untuk kebutuhan pemadam kebakaran. Berikut adalah spesifikasi utama:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Nilai Standar</th>
                                <th>Keterangan</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Tekanan Operasional</td>
                                <td>6-10 bar</td>
                                <td>Diukur dengan pressure gauge</td>
                            </tr>
                            <tr>
                                <td>Laju Alir</td>
                                <td>20-40 L/detik</td>
                                <td>Untuk kebutuhan darurat</td>
                            </tr>
                            <tr>
                                <td>Material</td>
                                <td>Baja atau kuningan</td>
                                <td>Tahan korosi</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Fungsi:</strong> Hydran memastikan pasokan air yang cepat dan andal untuk keadaan darurat. Pastikan hydran selalu dalam kondisi siap pakai dengan memeriksa tekanan dan status katup.</p>
                    <p><strong>Standar:</strong> Hydran harus memenuhi SNI 03-1745-2000 untuk sistem proteksi kebakaran.</p>
                `
            },
            {
                title: 'Pemeliharaan dan Uji Coba Hydran',
                content: `
                    <p>Pemeliharaan rutin diperlukan untuk memastikan hydran berfungsi optimal. Berikut adalah prosedur pemeliharaan:</p>
                    <ul>
                        <li><strong>Pemeriksaan Katup:</strong> Periksa katup hydran (biasanya gate valve) setiap bulan untuk memastikan tidak ada kebocoran atau penyumbatan.</li>
                        <li><strong>Pembersihan Nozzle:</strong> Bersihkan nozzle hydran dengan air bertekanan rendah untuk menghilangkan kotoran atau karat.</li>
                        <li><strong>Uji Alir:</strong> Lakukan uji alir setiap 6 bulan dengan menghubungkan selang ke hydran dan mengukur laju alir menggunakan flow meter.</li>
                        <li><strong>Pelumasan:</strong> Oleskan pelumas pada mekanisme katup untuk mencegah korosi dan memastikan operasi yang lancar.</li>
                    </ul>
                    <p><strong>Contoh Uji Coba:</strong> Uji alir pada hydran pilar di Blok P menunjukkan laju alir 30 L/detik pada tekanan 8 bar, sesuai dengan standar.</p>
                    <p><strong>Risiko:</strong> Penyumbatan nozzle dapat mengurangi laju alir hingga 50%, sehingga memengaruhi efektivitas pemadam kebakaran.</p>
                `
            },
            {
                title: 'Monitoring dan Pelaporan Hydran',
                content: `
                    <p>Monitoring hydran dilakukan untuk memastikan kesiapan sistem dalam keadaan darurat. Berikut adalah langkah-langkahnya:</p>
                    <ul>
                        <li><strong>Pencatatan Status:</strong> Catat status ON/OFF hydran dan tekanan operasional (bar) dalam checklist harian melalui aplikasi ini.</li>
                        <li><strong>Penggunaan Sensor:</strong> Pasang sensor tekanan pada hydran untuk memantau tekanan secara real-time. Data dapat diintegrasikan dengan sistem IoT untuk notifikasi otomatis.</li>
                        <li><strong>Pelaporan:</strong> Laporkan anomali seperti penurunan tekanan (<6 bar) atau kebocoran ke supervisor melalui fitur pelaporan kerusakan.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Hydran di Blok H menunjukkan tekanan 5 bar, di bawah standar. Setelah pemeriksaan, ditemukan kebocoran kecil pada katup yang diperbaiki dalam 2 jam.</p>
                    <p><strong>Standar:</strong> Tekanan hydran harus diperiksa sesuai NFPA 25 untuk sistem proteksi kebakaran.</p>
                `
            }
        ],
        'Pompa': [
            {
                title: 'Jenis dan Spesifikasi Pompa',
                content: `
                    <p>Pompa adalah komponen kunci dalam sistem WTP untuk transfer dan distribusi air. Berikut adalah jenis pompa yang umum digunakan:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Jenis Pompa</th>
                                <th>Kapasitas (m³/jam)</th>
                                <th>Head (m)</th>
                                <th>Kegunaan</th>
                                <th>Material</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Sentrifugal</td>
                                <td>10-100</td>
                                <td>10-50</td>
                                <td>Transfer air volume besar</td>
                                <td>Baja tahan karat</td>
                            </tr>
                            <tr>
                                <td>Submersible</td>
                                <td>5-50</td>
                                <td>20-100</td>
                                <td>Sumur bor, bak WWTP</td>
                                <td>Stainless steel</td>
                            </tr>
                            <tr>
                                <td>Booster</td>
                                <td>5-30</td>
                                <td>30-100</td>
                                <td>Meningkatkan tekanan</td>
                                <td>Baja atau kuningan</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Pemilihan Pompa:</strong> Pilih pompa berdasarkan kebutuhan laju alir dan tekanan. Contoh: Pompa booster cocok untuk distribusi air ke Blok A dengan tekanan rendah (<2 bar).</p>
                    <p><strong>Standar:</strong> Pompa harus memenuhi ISO 5199:2002 untuk performa dan keandalan.</p>
                `
            },
            {
                title: 'Pemeliharaan Pompa',
                content: `
                    <p>Pemeliharaan pompa diperlukan untuk menjaga efisiensi dan mencegah kerusakan. Berikut adalah prosedur pemeliharaan:</p>
                    <ul>
                        <li><strong>Pemeriksaan Seal:</strong> Periksa seal mekanis setiap bulan untuk mendeteksi kebocoran. Ganti seal jika ditemukan keausan.</li>
                        <li><strong>Monitoring Getaran:</strong> Gunakan vibration meter untuk mengukur getaran pompa. Getaran >4 mm/s menunjukkan masalah bantalan atau ketidakseimbangan.</li>
                        <li><strong>Pengukuran Suhu:</strong> Gunakan termometer inframerah untuk memantau suhu motor pompa (<80°C untuk operasi normal).</li>
                        <li><strong>Pelumasan:</strong> Ganti oli pelumas setiap 3-6 bulan atau setelah 2000 jam operasi, sesuai spesifikasi pompa.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Pompa sentrifugal di Blok P menunjukkan getaran 5 mm/s. Setelah pemeriksaan, bantalan diganti, mengembalikan getaran ke <2 mm/s.</p>
                    <p><strong>Risiko:</strong> Kebocoran seal dapat menyebabkan kehilangan air hingga 0.3 m³/jam dan kerusakan motor.</p>
                `
            },
            {
                title: 'Monitoring Efisiensi Pompa',
                content: `
                    <p>Monitoring efisiensi pompa penting untuk mengoptimalkan penggunaan energi dan air. Berikut adalah metode perhitungan dan monitoring:</p>
                    <ul>
                        <li><strong>Rumus Efisiensi:</strong> Efisiensi (%) = [(Laju Alir × Head × 9.81 × Densitas Air) / Daya Listrik] × 100.</li>
                        <li><strong>Langkah Monitoring:</strong>
                            <ol>
                                <li>Ukur laju alir (m³/jam) menggunakan flow meter.</li>
                                <li>Ukur head (m) menggunakan pressure gauge.</li>
                                <li>Ukur daya listrik (kW) menggunakan power meter.</li>
                                <li>Hitung efisiensi dan bandingkan dengan spesifikasi pompa (biasanya 70-85%).</li>
                            </ol>
                        </li>
                        <li><strong>Penggunaan Sensor:</strong> Pasang sensor IoT untuk memantau laju alir dan daya secara real-time. Data dapat diintegrasikan dengan aplikasi ini untuk analisis tren.</li>
                    </ul>
                    <p><strong>Contoh Kasus:</strong> Pompa di Blok E memiliki laju alir 50 m³/jam, head 20 m, dan daya 15 kW. Efisiensi dihitung: [(50 × 20 × 9.81 × 1000) / (15 × 1000)] × 100 = 65%. Penurunan efisiensi menunjukkan perlunya pembersihan impeller.</p>
                    <p><strong>Standar:</strong> Efisiensi pompa ideal sesuai ISO 9906:2012 adalah >70%.</p>
                `
            }
        ],
        'Jenis Jaringan': [
            {
                title: 'Jaringan Distribusi Air',
                content: `
                    <p>Jaringan distribusi air menghubungkan sumber air (PDAM, WTP) ke pengguna akhir di berbagai blok. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Struktur:</strong> Terdiri dari pipa induk (diameter 4-6 inci) dan pipa cabang (diameter 1-2 inci) untuk distribusi ke Blok A, B, C, dll.</li>
                        <li><strong>Tekanan Operasional:</strong> Harus dijaga antara 2-6 bar untuk memastikan aliran merata. Gunakan pressure gauge di titik-titik kritis (misalnya, sambungan blok).</li>
                        <li><strong>Monitoring:</strong> Catat pembacaan meter distribusi harian untuk mendeteksi anomali aliran, seperti kehilangan air akibat kebocoran.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Jaringan distribusi di Blok C menunjukkan penurunan tekanan dari 4 bar ke 1.5 bar, mengindikasikan penyumbatan pada pipa cabang.</p>
                    <p><strong>Standar:</strong> Desain jaringan harus sesuai SNI 03-7065-2005 untuk sistem perpipaan air minum.</p>
                `
            },
            {
                title: 'Jaringan WWTP',
                content: `
                    <p>Jaringan WWTP mengelola aliran air limbah dari berbagai blok ke bak penampungan atau unit pengolahan. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Struktur:</strong> Terdiri dari pipa pengumpul (diameter 3-6 inci) dan pipa distribusi menuju bak WWTP. Pipa HDPE sering digunakan karena tahan terhadap korosi.</li>
                        <li><strong>Pemantauan Aliran:</strong> Gunakan flow meter untuk memastikan tidak ada penyumbatan. Laju alir normal untuk WWTP adalah 10-50 m³/jam, tergantung kapasitas.</li>
                        <li><strong>Pencegahan Penyumbatan:</strong> Lakukan flushing jaringan setiap bulan dan periksa manhole untuk menghilangkan endapan.</li>
                    </ul>
                    <p><strong>Contoh Kasus:</strong> Penyumbatan pada jaringan WWTP di Blok P menyebabkan penurunan aliran dari 30 m³/jam ke 10 m³/jam. Pembersihan manhole mengembalikan aliran normal.</p>
                    <p><strong>Standar:</strong> Jaringan WWTP harus memenuhi Peraturan Menteri PU No. 01/PRT/M/2014 tentang pengelolaan air limbah.</p>
                `
            },
            {
                title: 'Jaringan PDAM',
                content: `
                    <p>Jaringan PDAM menyediakan air bersih dari sumber eksternal ke bak input WTP. Berikut adalah aspek utamanya:</p>
                    <ul>
                        <li><strong>Struktur:</strong> Pipa induk PDAM (diameter 6-8 inci) terhubung ke bak input dengan water meter induk untuk monitoring konsumsi.</li>
                        <li><strong>Pemantauan Konsumsi:</strong> Catat pembacaan meter induk PDAM harian untuk estimasi konsumsi. Contoh: Konsumsi harian 500 m³ untuk kebutuhan domestik dan industri.</li>
                        <li><strong>Deteksi Anomali:</strong> Bandingkan pembacaan meter induk dengan meter distribusi untuk mendeteksi kebocoran atau penggunaan tidak sah.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Pembacaan meter induk PDAM 1000 m³ dan total meter distribusi 950 m³ menunjukkan kehilangan 5%, yang memicu inspeksi kebocoran.</p>
                    <p><strong>Standar:</strong> Monitoring jaringan PDAM harus sesuai SNI 7507:2011 untuk pengelolaan air minum.</p>
                `
            }
        ],
        'Jenis Valve': [
            {
                title: 'Gate Valve',
                content: `
                    <p>Gate valve digunakan untuk mengisolasi aliran air secara penuh. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Fungsi:</strong> Cocok untuk aplikasi ON/OFF penuh, seperti mengisolasi pipa selama pemeliharaan.</li>
                        <li><strong>Spesifikasi:</strong> Tekanan maksimum 16 bar, material kuningan atau stainless steel, diameter 1-6 inci.</li>
                        <li><strong>Pemeliharaan:</strong> Periksa kebocoran pada seal setiap 3 bulan dan oleskan pelumas pada spindel untuk mencegah korosi.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Gate valve pada pipa induk di Blok A digunakan untuk mengisolasi aliran selama perbaikan kebocoran, mencegah kehilangan air 0.5 m³/jam.</p>
                    <p><strong>Standar:</strong> Gate valve harus memenuhi SNI 01-3538-1994 untuk katup air.</p>
                `
            },
            {
                title: 'Ball Valve',
                content: `
                    <p>Ball valve memungkinkan pengaturan aliran cepat dengan mekanisme putar 90 derajat. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Fungsi:</strong> Ideal untuk sistem distribusi yang membutuhkan respons cepat, seperti pengaturan aliran ke hydran.</li>
                        <li><strong>Spesifikasi:</strong> Tekanan maksimum 10 bar, material PVC atau kuningan, diameter 0.5-4 inci.</li>
                        <li><strong>Pemeliharaan:</strong> Periksa bola katup untuk memastikan tidak ada keausan atau kebocoran setiap 6 bulan.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Ball valve pada jaringan Blok C digunakan untuk mengatur aliran ke toilet, mengurangi konsumsi air dari 10 m³/hari ke 8 m³/hari.</p>
                    <p><strong>Standar:</strong> Ball valve harus sesuai dengan ISO 7121:2016 untuk performa katup.</p>
                `
            },
            {
                title: 'Check Valve',
                content: `
                    <p>Check valve mencegah aliran balik untuk melindungi pompa dan sistem distribusi. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Fungsi:</strong> Memastikan aliran searah, terutama pada sistem pompa atau jaringan WWTP.</li>
                        <li><strong>Spesifikasi:</strong> Tekanan maksimum 12 bar, material stainless steel atau kuningan, diameter 1-4 inci.</li>
                        <li><strong>Pemeliharaan:</strong> Periksa mekanisme pegas atau flap setiap 3 bulan untuk mencegah kebocoran balik.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Check valve pada pompa submersible di Blok P mencegah aliran balik, menjaga efisiensi pompa pada 80%.</p>
                    <p><strong>Standar:</strong> Check valve harus memenuhi SNI 01-3538-1994 untuk katup air.</p>
                `
            }
        ],
        'Jenis Hydran': [
            {
                title: 'Hydran Pilar',
                content: `
                    <p>Hydran pilar digunakan di area terbuka untuk kebutuhan darurat seperti pemadam kebakaran. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Spesifikasi:</strong> Tekanan 6-10 bar, laju alir 20-40 L/detik, memiliki 2-3 outlet, material kuningan atau baja.</li>
                        <li><strong>Pemeliharaan:</strong> Periksa outlet dan katup setiap bulan, lakukan uji alir setiap 6 bulan.</li>
                        <li><strong>Monitoring:</strong> Catat tekanan operasional menggunakan pressure gauge untuk memastikan kesiapan.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Hydran pilar di Blok P diuji dengan tekanan 8 bar dan laju alir 35 L/detik, memenuhi standar NFPA 25.</p>
                    <p><strong>Standar:</strong> Hydran pilar harus sesuai SNI 03-1745-2000.</p>
                `
            },
            {
                title: 'Hydran Bawah Tanah',
                content: `
                    <p>Hydran bawah tanah dipasang untuk estetika dan keamanan di area publik. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Spesifikasi:</strong> Tekanan 6-8 bar, laju alir 15-30 L/detik, memerlukan kunci khusus untuk akses, material stainless steel.</li>
                        <li><strong>Pemeliharaan:</strong> Bersihkan penutup hydran setiap bulan untuk mencegah korosi dan pastikan kunci akses berfungsi.</li>
                        <li><strong>Monitoring:</strong> Uji tekanan dan laju alir setiap 6 bulan untuk memastikan performa.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Hydran bawah tanah di Blok H diuji dengan laju alir 25 L/detik, memenuhi kebutuhan darurat.</p>
                    <p><strong>Standar:</strong> Hydran bawah tanah harus sesuai SNI 03-1745-2000.</p>
                `
            },
            {
                title: 'Hydran Dinding',
                content: `
                    <p>Hydran dinding dipasang di dalam gedung untuk kebutuhan darurat dalam ruangan. Berikut adalah karakteristiknya:</p>
                    <ul>
                        <li><strong>Spesifikasi:</strong> Tekanan 4-6 bar, laju alir 10-20 L/detik, material kuningan, diameter outlet 1-2 inci.</li>
                        <li><strong>Pemeliharaan:</strong> Periksa katup dan selang setiap 3 bulan untuk memastikan aksesibilitas dan fungsi.</li>
                        <li><strong>Monitoring:</strong> Catat status operasional dalam checklist harian untuk memastikan kesiapan.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Hydran dinding di Blok E diuji dengan tekanan 5 bar, cocok untuk kebutuhan dalam ruangan.</p>
                    <p><strong>Standar:</strong> Hydran dinding harus sesuai SNI 03-1745-2000.</p>
                `
            }
        ],
        'Jenis Water Meter': [
            {
                title: 'Water Meter Mekanis (Positive Displacement)',
                content: `
                    <p>Water meter mekanis tipe <em>positive displacement</em> (PD) bekerja dengan membagi aliran ke dalam ruang-ruang kecil sehingga air yang lewat secara fisik menggeser elemen ukur. Meter ini sangat akurat pada laju alir rendah hingga menengah dan lazim digunakan untuk rumah tangga serta usaha kecil【510129852877284†L292-L302】.</p>
                    <ul>
                        <li><strong>Spesifikasi:</strong> Akurasi ±2%, cocok untuk air bersih (TSS < 50&nbsp;ppm), ukuran 0.5–4&nbsp;inci.</li>
                        <li><strong>Pemeliharaan:</strong> Bersihkan elemen pengukur setiap 6&nbsp;bulan untuk mencegah penyumbatan sedimen.</li>
                        <li><strong>Monitoring:</strong> Catat pembacaan secara berkala dan bandingkan dengan tren historis untuk mendeteksi anomali.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Meter PD di area perumahan mencatat konsumsi 100&nbsp;m³/hari dengan akurasi baik.</p>
                    <p><strong>Standar:</strong> Meter PD harus memenuhi SNI&nbsp;2547:2008 untuk alat ukur air.</p>
                `
            },
            {
                title: 'Meter Kecepatan (Multi‑Jet/Turbin)',
                content: `
                    <p>Meter kecepatan mengukur kecepatan aliran air dan menghitung volume berdasarkan luas penampang pipa. Terdapat dua desain umum:</p>
                    <ul>
                        <li><strong>Multi‑Jet:</strong> Beberapa port kecil menghasilkan jet air yang memutar turbin. Meter ini sangat akurat pada debit rendah dan banyak digunakan untuk ukuran kecil【510129852877284†L327-L334】.</li>
                        <li><strong>Turbin:</strong> Turbin tunggal berputar sebanding dengan kecepatan aliran. Meter turbin dapat menangani debit tinggi dengan kehilangan tekanan yang rendah, tetapi kurang akurat pada debit sangat rendah【510129852877284†L343-L353】.</li>
                    </ul>
                    <p>Meter kecepatan cocok untuk aplikasi komersial atau kebakaran yang membutuhkan aliran tinggi.</p>
                    <p><strong>Standar:</strong> Meter kecepatan mengikuti ISO&nbsp;4064:2014.</p>
                `
            },
            {
                title: 'Water Meter Elektromagnetik',
                content: `
                    <p>Water meter elektromagnetik menggunakan medan magnet dan hukum induksi Faraday untuk mengukur laju aliran. Karena tidak ada bagian yang bergerak, meter ini memiliki pemeliharaan minimal dan mampu mengukur aliran dalam dua arah. Meter ini ideal untuk air baku atau air limbah dengan kandungan padatan tinggi【510129852877284†L388-L404】.</p>
                    <ul>
                        <li><strong>Spesifikasi:</strong> Akurasi ±0.5%, diameter 2–8&nbsp;inci.</li>
                        <li><strong>Pemeliharaan:</strong> Periksa elektroda dan bersihkan permukaan sensor setiap 12&nbsp;bulan untuk mencegah korosi.</li>
                        <li><strong>Monitoring:</strong> Integrasikan dengan sistem SCADA untuk mendapatkan data aliran real‑time.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Meter elektromagnetik di instalasi WWTP memantau aliran limbah industri 50&nbsp;m³/jam.</p>
                    <p><strong>Standar:</strong> Meter elektromagnetik harus memenuhi ISO&nbsp;4064:2014.</p>
                `
            },
            {
                title: 'Water Meter Ultrasonik',
                content: `
                    <p>Water meter ultrasonik menggunakan transduser ultrasonik untuk mengukur waktu tempuh gelombang suara di sepanjang pipa, lalu menghitung kecepatan aliran dan volume. Meter ini sangat akurat, dapat mengukur aliran sangat rendah, dan hampir tidak memerlukan perawatan karena tidak memiliki bagian bergerak【510129852877284†L408-L446】.</p>
                    <ul>
                        <li><strong>Spesifikasi:</strong> Akurasi ±1%, tahan terhadap sedimen, diameter 1–6&nbsp;inci.</li>
                        <li><strong>Pemeliharaan:</strong> Kalibrasi setiap 12&nbsp;bulan untuk menjaga akurasi.</li>
                        <li><strong>Monitoring:</strong> Dapat dilengkapi telemetri untuk mengirim data aliran secara real‑time ke pusat kontrol.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Meter ultrasonik pada saluran WWTP mencatat aliran 30&nbsp;m³/jam dengan akurasi tinggi dan mendeteksi anomali kebocoran.</p>
                    <p><strong>Standar:</strong> Meter ultrasonik harus memenuhi ISO&nbsp;4064:2014.</p>
                `
            }
        ],
        'Baku Mutu Air': [
            {
                title: 'Standar Kualitas Air',
                content: `
                    <p>Kualitas air harus memenuhi standar untuk memastikan aman digunakan. Berikut adalah parameter utama:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Standar</th>
                                <th>Alat Ukur</th>
                                <th>Frekuensi</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>pH</td>
                                <td>6.5-8.5</td>
                                <td>pH Meter</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>TDS</td>
                                <td>< 500 ppm</td>
                                <td>TDS Meter</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>Turbiditas</td>
                                <td>< 5 NTU</td>
                                <td>Turbidimeter</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>E. coli</td>
                                <td>0 CFU/100 mL</td>
                                <td>Kit Uji Bakteri</td>
                                <td>Mingguan</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Pengujian:</strong> Lakukan pengujian rutin menggunakan alat portabel dan kirim sampel ke laboratorium setiap bulan untuk verifikasi.</p>
                    <p><strong>Standar:</strong> Kualitas air harus sesuai Permenkes No. 492/Menkes/Per/IV/2010.</p>
                `
            },
            {
                title: 'Monitoring dan Analisis Kualitas Air',
                content: `
                    <p>Monitoring kualitas air dilakukan untuk memastikan air aman untuk distribusi. Berikut adalah prosedurnya:</p>
                    <ul>
                        <li><strong>Pengambilan Sampel:</strong> Ambil sampel air dari bak RO, WWTP, dan PDAM setiap hari pada titik distribusi utama.</li>
                        <li><strong>Pengukuran Parameter:</strong> Gunakan alat ukur pH, TDS, dan turbiditas untuk memantau kualitas air secara real-time.</li>
                        <li><strong>Analisis Tren:</strong> Simpan data kualitas air dalam database (misalnya, aplikasi ini) untuk analisis tren bulanan.</li>
                        <li><strong>Tindakan Korektif:</strong> Jika pH <6.5 atau TDS >500 ppm, lakukan penyesuaian di WTP atau laporkan ke supervisor.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Pengukuran TDS di Blok A menunjukkan 600 ppm, memicu pembersihan filter RO untuk mengembalikan TDS ke <500 ppm.</p>
                    <p><strong>Standar:</strong> Monitoring harus sesuai ISO 5667-5:2006 untuk pengambilan sampel air.</p>
                `
            }
        ],
        'Konsumsi Harian Air': [
            {
                title: 'Estimasi Konsumsi Air',
                content: `
                    <p>Estimasi konsumsi air penting untuk perencanaan distribusi dan penghematan. Berikut adalah metode estimasi:</p>
                    <ul>
                        <li><strong>Konsumsi Domestik:</strong> Rata-rata 100-150 L/orang/hari untuk kebutuhan toilet, kantin, dan mess.</li>
                        <li><strong>Konsumsi Industri:</strong> Rata-rata 500-1000 L/jam untuk cooling tower, mesin, dan laboratorium.</li>
                        <li><strong>Rumus Estimasi:</strong> Total Konsumsi = (Jumlah Pengguna × Konsumsi per Orang) + (Kapasitas Mesin × Jam Operasi).</li>
                        <li><strong>Data Historis:</strong> Gunakan data meter induk dan distribusi dari aplikasi ini untuk memprediksi konsumsi harian.</li>
                    </ul>
                    <p><strong>Contoh Perhitungan:</strong> Untuk 100 karyawan (150 L/orang) dan cooling tower (800 L/jam × 8 jam), total konsumsi = (100 × 150) + (800 × 8) = 21,400 L/hari.</p>
                    <p><strong>Standar:</strong> Estimasi konsumsi harus sesuai SNI 7507:2011.</p>
                `
            },
            {
                title: 'Strategi Penghematan Air',
                content: `
                    <p>Penghematan air dilakukan untuk mengurangi pemborosan dan biaya operasional. Berikut adalah strategi utama:</p>
                    <ul>
                        <li><strong>Deteksi Kebocoran:</strong> Bandingkan pembacaan meter induk dan distribusi harian untuk mendeteksi kehilangan air >5%.</li>
                        <li><strong>Audit Air:</strong> Lakukan audit bulanan untuk mengidentifikasi penggunaan berlebih di blok tertentu (misalnya, toilet di Blok C).</li>
                        <li><strong>Penggunaan Teknologi:</strong> Pasang flow restrictor pada kran dan gunakan sensor aliran untuk memantau konsumsi real-time.</li>
                        <li><strong>Edukasi Pengguna:</strong> Sosialisasikan pentingnya penghematan air kepada karyawan melalui pelatihan rutin.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Pemasangan flow restrictor di Blok E mengurangi konsumsi toilet dari 10 m³/hari ke 7 m³/hari.</p>
                    <p><strong>Standar:</strong> Penghematan air harus sesuai ISO 46001:2019 untuk manajemen air.</p>
                `
            }
        ],
        'Water Treatment Plant': [
            {
                title: 'Estimasi Kebutuhan Air',
                content: `
                    <p>Estimasi kebutuhan air di WTP dilakukan untuk memastikan pasokan memadai. Berikut adalah metode estimasi:</p>
                    <ul>
                        <li><strong>Rumus Estimasi:</strong> Kebutuhan Harian = (Rata-rata Pemakaian Harian × Jumlah Hari) + Buffer (10-20%).</li>
                        <li><strong>Data Historis:</strong> Gunakan data meter induk dan distribusi dari aplikasi ini untuk menghitung rata-rata pemakaian (misalnya, 500 m³/hari).</li>
                        <li><strong>Faktor Penyesuaian:</strong> Pertimbangkan peningkatan konsumsi selama musim kemarau (+15%) atau operasi mesin tambahan.</li>
                        <li><strong>Contoh Perhitungan:</strong> Untuk rata-rata 500 m³/hari dan buffer 15%, kebutuhan = 500 × 1.15 = 575 m³/hari.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Estimasi untuk Blok A dan B menunjukkan kebutuhan 600 m³/hari, memicu penyesuaian pasokan PDAM.</p>
                    <p><strong>Standar:</strong> Estimasi harus sesuai ISO 24512:2007 untuk pengelolaan air.</p>
                `
            },
            {
                title: 'Monitoring Sistem WTP',
                content: `
                    <p>Monitoring sistem WTP dilakukan untuk memastikan operasi yang efisien dan andal. Berikut adalah parameter utama:</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Parameter</th>
                                <th>Standar</th>
                                <th>Alat Ukur</th>
                                <th>Frekuensi</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Laju Alir Pompa</td>
                                <td>10-100 m³/jam</td>
                                <td>Flow Meter</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>Tekanan Pipa</td>
                                <td>2-6 bar</td>
                                <td>Pressure Gauge</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>Ketinggian Bak</td>
                                <td>50-200 cm</td>
                                <td>Level Sensor</td>
                                <td>Harian</td>
                            </tr>
                            <tr>
                                <td>Kualitas Air</td>
                                <td>pH 6.5-8.5, TDS <500 ppm</td>
                                <td>pH/TDS Meter</td>
                                <td>Harian</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Metode Monitoring:</strong> Gunakan sensor IoT untuk pengumpulan data real-time dan integrasikan dengan aplikasi ini untuk analisis tren.</p>
                    <p><strong>Contoh Aplikasi:</strong> Penurunan ketinggian bak RO ke 40 cm memicu aktivasi pompa booster untuk menjaga pasokan.</p>
                    <p><strong>Standar:</strong> Monitoring WTP harus sesuai ISO 24512:2007.</p>
                `
            },
            {
                title: 'Pemeliharaan Sistem Monitoring',
                content: `
                    <p>Pemeliharaan alat monitoring diperlukan untuk memastikan akurasi data. Berikut adalah prosedurnya:</p>
                    <ul>
                        <li><strong>Kalibrasi Flow Meter:</strong> Kalibrasi setiap 6 bulan menggunakan alat standar untuk memastikan akurasi ±1%.</li>
                        <li><strong>Pemeriksaan Pressure Gauge:</strong> Kalibrasi setiap 6 bulan dan periksa kebocoran pada sambungan.</li>
                        <li><strong>Pembersihan Sensor Level:</strong> Bersihkan sensor ketinggian bak setiap 3 bulan untuk mencegah endapan yang mengganggu pengukuran.</li>
                        <li><strong>Pembaruan Sistem:</strong> Perbarui perangkat lunak aplikasi ini setiap tahun untuk mendukung fitur monitoring baru.</li>
                    </ul>
                    <p><strong>Contoh Aplikasi:</strong> Kalibrasi flow meter di Blok P meningkatkan akurasi pengukuran dari ±3% ke ±1%, mengurangi kesalahan estimasi.</p>
                    <p><strong>Standar:</strong> Pemeliharaan alat ukur harus sesuai ISO 10012:2003 untuk sistem pengukuran.</p>
                `
            }
        ]
    };
    let filteredData = educationData[category] || [];
    if (search) {
        filteredData = filteredData.filter(item => 
            item.title.toLowerCase().includes(search) || 
            item.content.toLowerCase().includes(search)
        );
    }
    contentDiv.innerHTML = filteredData.length > 0 ? filteredData.map(item => `
        <div class="accordion">
            <div class="accordion-header">${item.title}</div>
            <div class="accordion-content">${item.content}</div>
        </div>
    `).join('') : '<p>Tidak ada konten yang sesuai dengan pencarian atau kategori yang dipilih.</p>';
    document.querySelectorAll('.accordion-header').forEach(header => {
        header.removeEventListener('click', toggleAccordion); 
        header.addEventListener('click', toggleAccordion);
    });
}

        /**
         * Load analysis data from the checklist collection and render charts.
         *
         * This function queries the Firestore collection for all checklist
         * documents, aggregates numeric fields by date, and produces line charts
         * for each numeric measurement.  It also computes basic summary
         * statistics (average, minimum, and maximum) to accompany each chart.
         * If no data is available the page displays a message.
         */
        async function loadAnalysisData() {
            const container = document.getElementById('analysisContent');
            if (!container) return;
            // Clear previous content and show a loading indicator
            container.innerHTML = '<p>Memuat analisis...</p>';
            // Jika modul Firestore tidak tersedia (misalnya karena skrip Firebase gagal dimuat),
            // tampilkan pesan dan hentikan fungsi.  Tanpa dependensi ini data checklist
            // tidak dapat diambil, sehingga analisis tidak bisa dilakukan.
            if (typeof getDocs !== 'function' || typeof collection !== 'function' || typeof query !== 'function') {
                container.innerHTML = '<p>Analisis tidak tersedia: modul Firebase tidak dimuat atau Anda sedang offline.</p>';
                return;
            }
            try {
                // Define the numeric fields to analyse along with labels, units and colours.
                // Restrict the analysis to only tank height measurements for RO distribution,
                // RO storage and PDAM.  Other metrics such as meter readings and flow
                // rates are omitted to focus on the tanks requested by the user.
                const fields = [
                    { field: 'tinggiRO', label: 'Ketinggian Bak Distribusi RO', unit: 'cm', color: '#4CAF50' },
                    { field: 'tinggiWWTP', label: 'Ketinggian Bak Tampung RO', unit: 'cm', color: '#2196F3' },
                    { field: 'tinggiPDAM', label: 'Ketinggian Bak PDAM', unit: 'cm', color: '#FF9800' }
                ];
                // Query all checklist documents ordered by date ascending so the
                // graphs display chronologically.  When offline or if no data
                // exists this call will return an empty snapshot.
                const snap = await getDocs(query(collection(db, 'checklists'), orderBy('date', 'asc')));
                const docs = snap.docs.map(doc => doc.data());
                // Prepare aggregated structures for each field keyed by date.
                const aggregated = {};
                fields.forEach(f => { aggregated[f.field] = {}; });
                docs.forEach(data => {
                    const dateKey = data.date || '';
                    fields.forEach(f => {
                        const value = parseFloat(data[f.field]);
                        if (!isNaN(value)) {
                            if (!aggregated[f.field][dateKey]) aggregated[f.field][dateKey] = [];
                            aggregated[f.field][dateKey].push(value);
                        }
                    });
                });
                // Check if there is any numeric data to display.  If all arrays
                // are empty then show a message instead of rendering charts.
                const hasData = fields.some(f => Object.keys(aggregated[f.field]).length > 0);
                if (!hasData) {
                    container.innerHTML = '<p>Tidak ada data checklist untuk dianalisis.</p>';
                    return;
                }
                // Remove the loading indicator before adding cards
                container.innerHTML = '';
                // For each numeric field construct a card with a chart and summary.
                fields.forEach((f, index) => {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.style.marginBottom = '20px';
                    // Title
                    const title = document.createElement('h3');
                    title.style.marginBottom = '10px';
                    title.textContent = f.label;
                    card.appendChild(title);
                    // Canvas for chart
                    const canvas = document.createElement('canvas');
                    const canvasId = `analysisChart_${index}`;
                    canvas.id = canvasId;
                    canvas.height = 200;
                    // Ensure the chart canvas fills the card width without stretching vertically.
                    // Explicitly setting width and height prevents the canvas from being pulled
                    // when its parent card is transformed.  Without these values, some browsers
                    // may calculate an excessive height, making the chart look distorted.
                    canvas.style.width = '100%';
                    canvas.style.maxWidth = '100%';
                    canvas.style.maxHeight = '200px';
                    card.appendChild(canvas);
                    // Compute average per date
                    const dates = Object.keys(aggregated[f.field]).sort((a, b) => new Date(a) - new Date(b));
                    const values = dates.map(date => {
                        const arr = aggregated[f.field][date];
                        const sum = arr.reduce((acc, v) => acc + v, 0);
                        return sum / arr.length;
                    });
                    // Append the card to the container before chart creation to ensure canvas is in the DOM
                    container.appendChild(card);
                    // Buat grafik hanya jika Chart.js tersedia.  Jika Chart.js tidak dimuat
                    // (misalnya saat offline) maka tambahkan pesan sederhana sebagai pengganti grafik.
                    if (typeof Chart !== 'undefined') {
                        const ctx = canvas.getContext('2d');
                        new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: dates,
                                datasets: [
                                    {
                                        label: f.label,
                                        data: values,
                                        borderColor: f.color,
                                        backgroundColor: f.color + '33', // add transparency for fill
                                        fill: true,
                                        tension: 0.4
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    x: {
                                        title: { display: true, text: 'Tanggal' }
                                    },
                                    y: {
                                        beginAtZero: false,
                                        title: { display: true, text: f.unit }
                                    }
                                },
                                plugins: {
                                    legend: { display: false }
                                }
                            }
                        });
                    } else {
                        // Jika Chart.js tidak tersedia, tampilkan placeholder teks.
                        const noChartMsg = document.createElement('p');
                        noChartMsg.style.fontSize = '12px';
                        noChartMsg.style.marginTop = '8px';
                        noChartMsg.textContent = 'Grafik tidak tersedia karena modul Chart tidak dimuat.';
                        card.appendChild(noChartMsg);
                    }
                    // Summary statistics
                    const allValues = Object.values(aggregated[f.field]).reduce((acc, arr) => acc.concat(arr), []);
                    if (allValues.length > 0) {
                        const sumAll = allValues.reduce((acc, v) => acc + v, 0);
                        const avgAll = sumAll / allValues.length;
                        const minAll = Math.min(...allValues);
                        const maxAll = Math.max(...allValues);
                        const summary = document.createElement('p');
                        summary.style.fontSize = '12px';
                        summary.style.marginTop = '8px';
                        summary.innerHTML =
                            `<strong>Rata-rata:</strong> ${avgAll.toFixed(2)} ${f.unit}, ` +
                            `<strong>Min:</strong> ${minAll.toFixed(2)} ${f.unit}, ` +
                            `<strong>Max:</strong> ${maxAll.toFixed(2)} ${f.unit}`;
                        card.appendChild(summary);
                    }
                });

            } catch (error) {
                console.error('Gagal memuat data analisis:', error);
                container.innerHTML = `<p>Terjadi kesalahan saat memuat analisis: ${error.message}</p>`;
            }
        }
function toggleAccordion(event) {
    const content = event.currentTarget.nextElementSibling;
    content.classList.toggle('active');
}
function showLoading(message = "Memproses...") {
    document.querySelector('#loadingOverlay .loading-text').innerText = message;
    document.getElementById('loadingOverlay').style.display = 'flex';
}
function hideLoading() {
    document.getElementById('loadingOverlay').style.display = 'none';
}

/**
 * Render a bar chart summarising how many checklist entries each user has
 * contributed.  The chart is appended as a new card into the provided
 * analysis container.  It queries all documents in the `checklists`
 * collection, aggregates counts by the `nik` field and displays the
 * result.  If Chart.js is unavailable, a textual fallback is displayed
 * instead.  The global variable `userActivityChart` holds a reference
 * to the chart so it can be destroyed between reloads.
 *
 * @param {HTMLElement} container The analysis content element into
 *        which the chart card should be appended.
 */
async function renderUserActivityChart(container) {
    if (!container) return;
    // If Firestore dependencies are missing (e.g. when offline), show a simple
    // placeholder card instead of attempting to query data.
    if (typeof getDocs !== 'function' || typeof collection !== 'function') {
        const fallbackCard = document.createElement('div');
        fallbackCard.className = 'card';
        fallbackCard.style.marginBottom = '20px';
        const title = document.createElement('h3');
        title.textContent = 'Grafik Keaktifan Kontribusi Pengguna';
        fallbackCard.appendChild(title);
        const msg = document.createElement('p');
        msg.style.fontSize = '12px';
        msg.style.marginTop = '8px';
        msg.textContent = 'Grafik keaktifan tidak tersedia karena modul Firebase tidak dimuat.';
        fallbackCard.appendChild(msg);
        container.appendChild(fallbackCard);
        return;
    }
    // Fetch all checklist documents from Firestore to compute per-user counts
    let snap;
    try {
        snap = await getDocs(collection(db, 'checklists'));
    } catch (err) {
        console.error('Error querying user activity:', err);
        return;
    }
    const counts = {};
    snap.forEach(docSnap => {
        const data = docSnap.data() || {};
        const nik = data.nik || 'Tidak diketahui';
        counts[nik] = (counts[nik] || 0) + 1;
    });
    const labels = Object.keys(counts);
    const values = labels.map(nik => counts[nik]);
    // Sort descending by count to highlight most active users
    const combined = labels.map((nik, i) => ({ nik, count: values[i] }));
    combined.sort((a, b) => b.count - a.count);
    const sortedLabels = combined.map(item => item.nik);
    const sortedCounts = combined.map(item => item.count);
    // Create a new card for the activity chart
    const card = document.createElement('div');
    card.className = 'card';
    card.style.marginBottom = '20px';
    const titleEl = document.createElement('h3');
    titleEl.style.marginBottom = '10px';
    titleEl.textContent = 'Grafik Keaktifan Kontribusi Pengguna';
    card.appendChild(titleEl);
    const canvas = document.createElement('canvas');
    canvas.id = 'userActivityChartCanvas';
    canvas.height = 200;
    canvas.style.width = '100%';
    canvas.style.maxWidth = '100%';
    canvas.style.maxHeight = '200px';
    card.appendChild(canvas);
    container.appendChild(card);
    // Draw the bar chart if Chart.js is available
    if (typeof Chart !== 'undefined') {
        // Destroy the previous instance if it exists
        if (userActivityChart) {
            try {
                userActivityChart.destroy();
            } catch (e) {
                console.warn('Could not destroy previous activity chart:', e);
            }
        }
        const ctx = canvas.getContext('2d');
        userActivityChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: sortedLabels,
                datasets: [
                    {
                        label: 'Jumlah Laporan',
                        data: sortedCounts,
                        backgroundColor: '#FFC107',
                        borderColor: '#FFA000',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: 'NIK' },
                        ticks: { autoSkip: false, maxRotation: 45, minRotation: 45 }
                    },
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: 'Jumlah Laporan' }
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });
    } else {
        // Provide a fallback message if Chart.js is unavailable
        const noChart = document.createElement('p');
        noChart.style.fontSize = '12px';
        noChart.style.marginTop = '8px';
        noChart.textContent = 'Grafik keaktifan tidak tersedia karena modul Chart tidak dimuat.';
        card.appendChild(noChart);
    }
}
async function deleteData() {
    console.log('deleteData function called');
    if (currentNIK !== 'CA00383') {
        showNotification('Hanya NIK CA00383 yang dapat mengakses fitur ini.');
        return;
    }
    const dataType = document.getElementById('dataType').value;
    const deleteDate = document.getElementById('dataDeleteDate').value;
    const button = document.getElementById('deleteDataButton');
    if (!dataType || !deleteDate) {
        showNotification('Mohon pilih tipe data dan tanggal!');
        return;
    }
    button.classList.add('loading');
    button.disabled = true;
    try {
        const dateObj = new Date(deleteDate);
        const formattedDate = dateObj.toLocaleDateString('id-ID');
        const q = query(collection(db, dataType), where('date', '==', formattedDate));
        const snapshot = await getDocs(q);
        if (snapshot.empty) {
            showNotification(`Tidak ada data ${dataType} untuk tanggal ${formattedDate}`);
            return;
        }
        // Ask for confirmation before deleting.  Use the number of matching
        // documents in the message to clearly communicate the scope of the action.
        showConfirm(`Apakah Anda yakin ingin menghapus ${snapshot.docs.length} data ${dataType} untuk tanggal ${formattedDate}?`, async () => {
            try {
                const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
                await Promise.all(deletePromises);
                showNotification(`Berhasil menghapus ${snapshot.docs.length} data ${dataType} untuk tanggal ${formattedDate}!`, true);
                if (dataType === 'checklists') {
                    listenReports(1);
                    populateFilters();
                } else if (dataType === 'meters') {
                    listenMeterReports(1);
                    populateMeterFilterDate();
                } else if (dataType === 'damages') {
                    listenDamageReports(1);
                    populateDamageFilterDate();
                }
            } catch (err) {
                console.error('Gagal menghapus data:', err);
                showNotification(`Gagal menghapus data: ${err.message}`);
            } finally {
                button.classList.remove('loading');
                button.disabled = false;
            }
        }, () => {
            // Cancellation callback.  Simply reset the button state.
            button.classList.remove('loading');
            button.disabled = false;
        });
        // Early return: further actions are handled in the confirmation callbacks.
        return;
    } catch (error) {
        console.error('Gagal menghapus data:', error);
        showNotification(`Gagal menghapus data: ${error.message}`);
    }
    // Ensure the button state is reset if an exception occurs before the
    // confirmation modal is displayed.
    button.classList.remove('loading');
    button.disabled = false;
}
document.addEventListener('DOMContentLoaded', () => {
    const savedTheme = localStorage.getItem('theme') || 'light';
    document.body.className = `${savedTheme}-theme`;
    const themeIcon = document.getElementById('themeIcon');
    if (themeIcon) {
        themeIcon.className = `fas ${savedTheme === 'light' ? 'fa-moon' : 'fa-sun'}`;
    }
    document.getElementById('landingPage').style.display = 'flex';
    document.getElementById('loginPage').style.display = 'none';
    document.getElementById('themeToggle').addEventListener('click', toggleTheme);
    document.getElementById('loginButton').addEventListener('click', login);
    document.getElementById('nikInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') login();
    });
    // Auto-fill the name input when the NIK matches a registered user.
    // This listener watches changes to the NIK field and, if the value corresponds
    // to a known NIK in the users array, it automatically populates the name
    // input.  The match is case-insensitive for the NIK.  When no match is
    // found, the name field is left untouched to avoid overwriting any user
    // input.
    const nikField = document.getElementById('nikInput');
    const autoNameField = document.getElementById('nameInput');
    if (nikField && autoNameField) {
        nikField.addEventListener('input', () => {
            const nikVal = nikField.value.trim().toUpperCase();
            if (nikVal.length === 7) {
                const match = users.find(u => u.nik.toUpperCase() === nikVal);
                if (match) {
                    autoNameField.value = match.name;
                }
            }
        });
    }
    // Allow pressing Enter in the name input to trigger the login action as well.
    const nameInputField = document.getElementById('nameInput');
    if (nameInputField) {
        nameInputField.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') login();
        });
    }
    document.querySelectorAll('.nav-item').forEach(item => {
        item.addEventListener('click', () => {
            // Handle attendance page separately to populate staff list and update greeting
            if (item.dataset.page === 'attendancePage') {
                showAttendancePage();
            } else {
                switchPage(item.dataset.page);
            }
        });
    });
    document.getElementById('switchMasuk').addEventListener('click', () => switchType('masuk'));
    document.getElementById('switchPulang').addEventListener('click', () => switchType('pulang'));
    document.getElementById('switchCustom').addEventListener('click', () => switchType('custom'));
    document.getElementById('checklistForm').addEventListener('submit', saveChecklist);
    document.getElementById('meterForm').addEventListener('submit', saveMeter);
    // Attach damage form events only if the elements exist (damage page removed in simplified version)
    const damageFormEl = document.getElementById('damageForm');
    if (damageFormEl) {
        damageFormEl.addEventListener('submit', saveDamage);
    }
    document.getElementById('estimationForm').addEventListener('submit', calculateEstimation);
    // Removed bulk data deletion button listener.  Deletion of reports is handled via per‑row actions.
    document.getElementById('modalClose').addEventListener('click', closeModal);
    document.getElementById('modalOverlay').addEventListener('click', closeModal);
    document.getElementById('meterBlock').addEventListener('change', (e) => populateLocations('meterLocation', e.target.value));
    const damageBlockEl = document.getElementById('damageBlock');
    if (damageBlockEl) {
        damageBlockEl.addEventListener('change', (e) => populateLocations('damageLocation', e.target.value));
    }
    document.getElementById('filterDate').addEventListener('change', () => listenReports(1));
    document.getElementById('filterShift').addEventListener('change', () => listenReports(1));
    document.getElementById('filterNIK').addEventListener('change', () => listenReports(1));
    // Only attach meter filter listeners if the elements exist (the Excel-style sheet replaces these filters)
    const meterFilterBlockEl = document.getElementById('meterFilterBlock');
    if (meterFilterBlockEl) {
        meterFilterBlockEl.addEventListener('change', () => listenMeterReports(1));
    }
    const meterFilterDateEl = document.getElementById('meterFilterDate');
    if (meterFilterDateEl) {
        meterFilterDateEl.addEventListener('change', () => listenMeterReports(1));
    }
    const damageFilterBlockEl2 = document.getElementById('damageFilterBlock');
    if (damageFilterBlockEl2) {
        damageFilterBlockEl2.addEventListener('change', () => listenDamageReports(1));
    }
    const damageFilterDateEl2 = document.getElementById('damageFilterDate');
    if (damageFilterDateEl2) {
        damageFilterDateEl2.addEventListener('change', () => listenDamageReports(1));
    }
    document.getElementById('educationSearch').addEventListener('input', loadEducationContent);
    document.getElementById('educationCategory').addEventListener('change', loadEducationContent);
    document.getElementById('reportBody').addEventListener('click', (e) => {
        if (e.target.classList.contains('detail-btn')) {
            showDetail(JSON.parse(e.target.dataset.detail));
        }
        if (e.target.classList.contains('whatsapp-btn') || e.target.parentElement.classList.contains('whatsapp-btn')) {
            const data = JSON.parse(e.target.dataset.detail || e.target.parentElement.dataset.detail);
            shareChecklist(data);
        }
        if (e.target.classList.contains('edit-btn')) {
            showEditForm(JSON.parse(e.target.dataset.detail));
        }
        // Handle deletion of reports.  Confirm with the user before deleting the
        // document from Firestore to prevent accidental removals.  Use the
        // document id stored in the data-detail attribute for the deleteDoc call.
        if (e.target.classList.contains('delete-btn') || (e.target.parentElement && e.target.parentElement.classList.contains('delete-btn'))) {
            const detailStr = e.target.dataset.detail || e.target.parentElement.dataset.detail;
            const data = JSON.parse(detailStr);
            // Use a custom confirmation modal instead of the native confirm dialog.  This
            // modal preserves the app’s aesthetic and avoids showing the browser’s
            // domain in the prompt.
            showConfirm('Apakah Anda yakin ingin menghapus laporan ini?', async () => {
                try {
                    await deleteDoc(doc(db, 'checklists', data.id));
                    showNotification('Laporan berhasil dihapus!', true);
                } catch (error) {
                    console.error('Gagal menghapus laporan:', error);
                    showNotification(`Gagal menghapus laporan: ${error.message}`);
                }
            });
        }
    });
    document.getElementById('meterReportBody').addEventListener('click', (e) => {
        if (e.target.classList.contains('whatsapp-btn') || e.target.parentElement.classList.contains('whatsapp-btn')) {
            const data = JSON.parse(e.target.dataset.detail || e.target.parentElement.dataset.detail);
            const message = `
• Laporan Meter Air
• Tanggal: ${data.date || '-'}
• Waktu: ${data.time || '-'}
• Blok: ${data.block || '-'}
• Lokasi: ${data.location || '-'}
• Angka Meter: ${data.meterReading || 0} m³
Catatan: ${data.notes || '-'}
            `.trim();
            const encodedMessage = encodeURIComponent(message);
            window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');
        }
    });
    document.getElementById('damageReportBody').addEventListener('click', (e) => {
        // Determine the button that was clicked. If the target is an <i> icon or another
        // element inside the button, traverse up to the nearest <button> ancestor. This
        // ensures that clicks on nested elements (e.g. icons) still reference the correct
        // button element.
        const button = e.target.tagName === 'BUTTON' ? e.target : e.target.closest('button');
        // Exit if no button was found or the button does not contain detail data.
        if (!button || !button.dataset || !button.dataset.detail) {
            return;
        }
        // Restore the original JSON string by converting the &quot; HTML entities back to
        // double quotes. The damage data was serialized with double quotes replaced by
        // &quot; to safely embed it in the markup. Here we reverse that substitution so
        // JSON.parse can consume a valid JSON string.
        let detailStr = button.dataset.detail.replace(/&quot;/g, '"');
        let data;
        try {
            data = JSON.parse(detailStr);
        } catch (err) {
            console.error('Failed to parse damage detail JSON:', err, detailStr);
            return;
        }
        // Determine the action based on the button's class. Each button in the
        // damage report row has a distinct class indicating its purpose. Execute
        // the corresponding handler and return early to avoid fall-through.
        if (button.classList.contains('preview-btn')) {
            showDamageDetail(data);
            return;
        }
        if (button.classList.contains('edit-damage-btn')) {
            showDamageEditForm(data);
            return;
        }
        if (button.classList.contains('whatsapp-btn')) {
            // Build a WhatsApp message with the damage report details. Include
            // the photo URL if one is available. Newlines are escaped and the
            // message is URL-encoded before opening WhatsApp.
            let message = `\n• Laporan Kerusakan\n• Tanggal: ${data.date || '-'}\n• Jenis Kerusakan: ${data.damageType || '-'}\n• Blok: ${data.block || '-'}\n• Lokasi: ${data.location || '-'}\n• Spesifik: ${data.specific || '-'}\nCatatan: ${data.notes || '-'}`.trim();
            if (data.photoUrl) {
                message += `\nFoto: ${data.photoUrl}`;
            }
            const encodedMessage = encodeURIComponent(message);
            window.open(`https://wa.me/?text=${encodedMessage}`, '_blank');
            return;
        }
    });
    // Populate filter dropdowns for legacy meter table only if the elements exist
    const meterFilterBlockEl2 = document.getElementById('meterFilterBlock');
    if (meterFilterBlockEl2) {
        populateMeterFilterBlock();
        // also populate filter dates if needed
        populateMeterFilterDate();
    }
    populateDamageFilterBlock();
    // Populate damage filter date options on load
    populateDamageFilterDate();
    // Attach change listeners to file inputs for image preview
    const dmgPhotoInput = document.getElementById('damagePhoto');
    if (dmgPhotoInput) {
        dmgPhotoInput.addEventListener('change', function() {
            // Preview the selected image and update the custom label
            updateDamageImagePreview(this);
            updateFileLabel(this);
        });
    }
    const dmgUploadInput = document.getElementById('damageUpload');
    if (dmgUploadInput) {
        dmgUploadInput.addEventListener('change', function() {
            updateDamageImagePreview(this);
            updateFileLabel(this);
        });
    }
    // Close button for damage detail modal
    const dmgDetailCloseBtn = document.getElementById('damageDetailClose');
    if (dmgDetailCloseBtn) {
        dmgDetailCloseBtn.addEventListener('click', () => {
            document.getElementById('damageDetailModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
        });
    }
    // panggil updateTime sekali supaya waktu langsung tampil, lalu atur interval setiap detik
    updateTime();
    setInterval(updateTime, 1000);

    // Bind attendance toggle to show the attendance dashboard
    const attendanceToggleEl = document.getElementById('attendanceToggle');
    if (attendanceToggleEl) {
        attendanceToggleEl.addEventListener('click', showAttendancePage);
    }
});
    function hitungStatus(ketinggian) {
        if (ketinggian >= 150) return "Optimal";
        if (ketinggian >= 100) return "Normal";
        return "Rendah";
    }
    function updateStatusOutputs() {
        const tinggiRO = parseFloat(document.getElementById('tinggiRO').value) || 0;
        const tinggiWWTP = parseFloat(document.getElementById('tinggiWWTP').value) || 0;
        const tinggiPDAM = parseFloat(document.getElementById('tinggiPDAM').value) || 0;
        const statusRO = hitungStatus(tinggiRO);
        const statusWWTP = hitungStatus(tinggiWWTP);
        const statusPDAM = hitungStatus(tinggiPDAM);
        document.getElementById('bakRO').value = statusRO;
        document.getElementById('bakWWTP').value = statusWWTP;
        document.getElementById('statusPDAM').value = statusPDAM;
        const roText = document.getElementById('statusROText');
        const wwtpText = document.getElementById('statusWWTPText');
        const pdamText = document.getElementById('statusPDAMText');
        if (roText) roText.textContent = statusRO;
        if (wwtpText) wwtpText.textContent = statusWWTP;
        if (pdamText) pdamText.textContent = statusPDAM;
    }
    window.addEventListener('DOMContentLoaded', () => {
        ['tinggiRO', 'tinggiWWTP', 'tinggiPDAM'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('input', updateStatusOutputs);
            }
        });
        const checklistForm = document.getElementById('checklistForm');
        if (checklistForm) {
            checklistForm.addEventListener('submit', function (e) {
                updateStatusOutputs(); 
            });
        }
        // No bulk deletion button exists; no need to bind deletion events here.
        const loginBtn = document.getElementById('loginButton');
        if (loginBtn) {
            loginBtn.addEventListener('click', login);
        }
    });
document.getElementById('loginFromLanding').addEventListener('click', () => {
    document.getElementById('landingPage').style.display = 'none';
    document.getElementById('loginPage').style.display = 'block';
});
document.getElementById('showGuide').addEventListener('click', () => {
    document.getElementById('guideModal').style.display = 'block';
});
document.getElementById('closeGuide').addEventListener('click', () => {
    document.getElementById('guideModal').style.display = 'none';
});
document.getElementById('guideModal').addEventListener('click', (e) => {
    if (e.target === document.getElementById('guideModal')) {
        document.getElementById('guideModal').style.display = 'none';
    }
});
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.getElementById('guideModal').style.display === 'block') {
        document.getElementById('guideModal').style.display = 'none';
    }
});
document.querySelectorAll('.btn, .landing-btn, td button, .switch-btn').forEach(button => {
    button.addEventListener('click', function(e) {
        const rect = this.getBoundingClientRect();
        const ripple = document.createElement("span");
        ripple.classList.add("ripple-anim");
        ripple.style.left = (e.clientX - rect.left) + "px";
        ripple.style.top = (e.clientY - rect.top) + "px";
        this.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
    }, false);
});
const observer = new MutationObserver(mutations => {
    mutations.forEach(mutation => {
        if (mutation.target.style.display === 'block') {
            mutation.target.classList.add('page-fade-in');
            setTimeout(() => mutation.target.classList.remove('page-fade-in'), 500);
        }
    });
});
document.querySelectorAll('#landingPage, #loginPage, #mainPage, #meterPage, #damagePage, #estimationPage, #educationPage')
    .forEach(page => {
        observer.observe(page, { attributes: true, attributeFilter: ['style'] });
    });
window.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('#landingPage .landing-hero, #landingPage .feature-card').forEach((el, index) => {
        el.style.animationDelay = `${index * 0.15}s`;
        el.classList.add('staggered');
    });
});
function showErrorShake(selector) {
    const el = document.querySelector(selector);
    if (!el) return;
    el.classList.add('shake');
    setTimeout(() => el.classList.remove('shake'), 400);
}
function setButtonLoading(btn, isLoading, originalText = null) {
    if (isLoading) {
        if (!btn.dataset.originalText) {
            btn.dataset.originalText = btn.innerHTML;
        }
        btn.classList.add('loading');
        btn.disabled = true;
    } else {
        btn.classList.remove('loading');
        btn.disabled = false;
        if (btn.dataset.originalText) {
            btn.innerHTML = btn.dataset.originalText;
            delete btn.dataset.originalText;
        }
    }
}
const checklistForm = document.getElementById('checklistForm');
if (checklistForm) {
    checklistForm.addEventListener('submit', e => {
        e.preventDefault();
        const btn = document.getElementById('saveChecklistButton');
        setButtonLoading(btn, true);
        setTimeout(() => {
            setButtonLoading(btn, false);
            showSuccessCheck();
        }, 1000);
    });
}
function showPageWithDirection(pageId, direction = 'right') {
    document.querySelectorAll('#landingPage, #loginPage, #mainPage, #meterPage, #damagePage, #estimationPage, #educationPage')
        .forEach(p => p.style.display = 'none');
    const page = document.getElementById(pageId);
    if (page) {
        page.style.display = 'block';
        page.classList.add(direction === 'left' ? 'page-slide-left' : 'page-slide-right');
        setTimeout(() => {
            page.classList.remove('page-slide-left', 'page-slide-right');
        }, 400);
    }
}
async function checkPing(url = "/favicon.ico", timeout = 3000) {
    const start = Date.now();
    try {
        const controller = new AbortController();
        const timer = setTimeout(() => controller.abort(), timeout);
        await fetch(url + "?t=" + Date.now(), { cache: "no-store", signal: controller.signal });
        clearTimeout(timer);
        return Date.now() - start;
    } catch {
        return null;
    }
}
async function updateConnectionPanel() {
    const navBar = document.getElementById("navBar");
    if (!navBar) return;
    
    let statusEl = document.getElementById("inlineStatus");
    
    if (!statusEl) {
        statusEl = document.createElement("div");
        statusEl.id = "inlineStatus";
        statusEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.4);
            padding: 6px 10px;
            border-radius: 15px;
            backdrop-filter: blur(8px);
            z-index: 2000;
            font-family: inherit;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        `;
        statusEl.innerHTML = '<div id="statusDot" style="width: 6px; height: 6px; border-radius: 50%; background: #48bb78;"></div><span id="statusText">Online</span>';
        document.body.appendChild(statusEl);
    }

    if (document.getElementById("loginPage").style.display !== "none") {
        statusEl.style.display = "none";
        return;
    } else {
        statusEl.style.display = "inline-flex";
    }

    const dot = document.getElementById("statusDot");
    const text = document.getElementById("statusText");
    
    if (!navigator.onLine) {
        dot.style.cssText = "width: 6px; height: 6px; border-radius: 50%; background: #f56565; animation: blink 1s infinite;";
        text.textContent = "Offline";
        return;
    }

    const ping = await checkPing();
    
    if (ping === null) {
        dot.style.cssText = "width: 6px; height: 6px; border-radius: 50%; background: #f56565; animation: blink 1s infinite;";
        text.textContent = "No Connection";
    } else if (ping > 600) {
        dot.style.cssText = "width: 6px; height: 6px; border-radius: 50%; background: #f56565; animation: blink 1s infinite;";
        text.textContent = `Poor (${ping}ms)`;
    } else if (ping > 300) {
        dot.style.cssText = "width: 6px; height: 6px; border-radius: 50%; background: #ed8936;";
        text.textContent = `Slow (${ping}ms)`;
    } else {
        dot.style.cssText = "width: 6px; height: 6px; border-radius: 50%; background: #48bb78;";
        text.textContent = `Online (${ping}ms)`;
    }
}
window.addEventListener("online", updateConnectionPanel);
window.addEventListener("offline", updateConnectionPanel);
setInterval(updateConnectionPanel, 5000);
updateConnectionPanel();
const animations = [
    {id: 'anim1', path: 'packaging-for-delivery.json'},
    {id: 'anim2', path: 'singing-contract.json'},
    {id: 'anim3', path: 'singing-contract.json'},
    {id: 'anim4', path: 'website-maintenance.json'},
    {id: 'anim5', path: 'growth-analysis.json'},
    // Animation for the new attendance dashboard page
    {id: 'attendanceAnim', path: 'creative-team.json'},
    // Added animations for the landing hero, login card and analysis page
    {id: 'landingAnimation', path: 'creative-team.json'},
    {id: 'loginAnimation', path: 'packaging-for-delivery.json'},
    {id: 'analysisAnim', path: 'growth-analysis.json'},
];
animations.forEach(anim => {
    lottie.loadAnimation({
        container: document.getElementById(anim.id),
        renderer: 'svg',
        loop: true,
        autoplay: true,
        path: anim.path
    });
});
function showSuccessAnimation(onFinish) {
    const successContainer = document.getElementById('successCheck');
    const animContainer = document.getElementById('successAnimation');
    animContainer.innerHTML = '';
    successContainer.style.display = 'flex';
    const anim = lottie.loadAnimation({
        container: animContainer,
        renderer: 'svg',
        loop: false,
        autoplay: true,
        path: 'successfully-done.json'
    });
    anim.setSpeed(1.0);
    anim.addEventListener('complete', () => {
        successContainer.style.display = 'none';
        if (typeof onFinish === 'function') onFinish();
    });
    // Fallback: in case the animation file fails to load or the complete event
    // never fires (e.g. offline or missing asset), hide the overlay and
    // invoke the callback after a short delay to avoid blocking the UI.
    setTimeout(() => {
        if (successContainer.style.display !== 'none') {
            successContainer.style.display = 'none';
            if (typeof onFinish === 'function') onFinish();
        }
    }, 2000);
}

// ==================== Meter Excel-style Sheet Functions ====================
/**
 * Populate block select for meter sheet using blockLocations keys.
 */
function populateSheetBlockSelect() {
    const select = document.getElementById('sheetBlockSelect');
    if (!select) return;
    select.innerHTML = '';
    // Sort blocks alphabetically with "Induk" first for consistent ordering
    const blocks = Object.keys(blockLocations || {}).sort((a, b) => {
        if (a === 'Induk') return -1;
        if (b === 'Induk') return 1;
        return a.localeCompare(b);
    });
    blocks.forEach(block => {
        const opt = document.createElement('option');
        opt.value = block;
        opt.textContent = block;
        select.appendChild(opt);
    });

    // After populating the hidden select, also build the visible block tabs
    if (typeof populateBlockTabs === 'function') {
        populateBlockTabs();
    }
}

/**
 * Create clickable tabs for each meter block and attach to the blockTabs container.
 * When a tab is selected, it updates the hidden block select value, highlights the
 * active tab, and triggers loading of the meter sheet if a month is selected.
 */
function populateBlockTabs() {
    const tabContainer = document.getElementById('blockTabs');
    const selectEl = document.getElementById('sheetBlockSelect');
    if (!tabContainer || !selectEl) return;
    // Clear existing tabs
    tabContainer.innerHTML = '';
    // Collect available block names and sort them alphabetically with "Induk"
    // always appearing first.  Using localeCompare ensures Indonesian locale
    // sorting rules where applicable.
    const blocks = Object.keys(blockLocations || {}).sort((a, b) => {
        if (a === 'Induk') return -1;
        if (b === 'Induk') return 1;
        return a.localeCompare(b);
    });
    blocks.forEach(block => {
        const tab = document.createElement('div');
        tab.className = 'block-tab';
        tab.textContent = block;
        tab.dataset.block = block;
        // Mark active if it matches current select value
        if (selectEl.value === block) {
            tab.classList.add('active');
        }
        // Click handler for selecting block
        tab.addEventListener('click', () => {
            // Helper to perform the block switch.  This sets the hidden select,
            // updates the active tab styling and triggers loading of the sheet.
            const performSwitch = () => {
                selectEl.value = block;
                tabContainer.querySelectorAll('.block-tab').forEach(el => el.classList.remove('active'));
                tab.classList.add('active');
                loadMeterSheet();
            };
            // If there are unsaved changes on the current sheet, show a custom
            // confirmation modal instead of the native confirm().  Only when
            // the user confirms will the changes be discarded.
            if (window.unsavedSheetChanges) {
                showConfirm('Anda memiliki perubahan yang belum disimpan. Tetap beralih ke blok lain?', () => {
                    window.unsavedSheetChanges = false;
                    performSwitch();
                });
            } else {
                performSwitch();
            }
        });
        tabContainer.appendChild(tab);
    });
}
/**
 * Load meter sheet data for selected block and month.
 */
async function loadMeterSheet() {
    // Warn the user if there are unsaved changes from previous edits.  Switching
    // the sheet (either by changing block or month) will discard those changes.
    if (window.unsavedSheetChanges) {
        const proceed = await new Promise(resolve => {
            showConfirm('Anda memiliki perubahan yang belum disimpan. Memuat sheet baru akan membatalkan perubahan tersebut. Lanjutkan?', () => resolve(true), () => resolve(false));
        });
        if (!proceed) {
            return;
        }
        // User chose to discard changes; reset flag
        window.unsavedSheetChanges = false;
    }
    const blockEl = document.getElementById('sheetBlockSelect');
    const monthEl = document.getElementById('sheetMonthSelect');
    if (!blockEl || !monthEl) return;
    const block = blockEl.value;
    const monthValue = monthEl.value; // format "YYYY-MM"
    if (!block || !monthValue) {
        showNotification('Pilih blok dan bulan untuk menampilkan sheet.');
        return;
    }
    const [yearStr, monthStr] = monthValue.split('-');
    const year = parseInt(yearStr);
    const month = parseInt(monthStr);
    if (isNaN(year) || isNaN(month)) {
        showNotification('Format bulan tidak valid.');
        return;
    }
    const daysInMonth = new Date(year, month, 0).getDate();
    // fetch meter docs for selected block
    let meterDocs = [];
    try {
        const q = query(collection(db, 'meters'), where('block', '==', block));
        const snapshot = await getDocs(q);
        meterDocs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
        console.error('Error fetching meter docs for sheet:', error);
        showNotification('Gagal memuat data meter: ' + error.message);
        return;
    }
    // filter docs by selected month/year
    meterDocs = meterDocs.filter(doc => {
        if (!doc.date) return false;
        const parts = doc.date.split('/');
        if (parts.length !== 3) return false;
        const day = parseInt(parts[0]);
        const monthLocal = parseInt(parts[1]);
        const yearLocal = parseInt(parts[2]);
        return yearLocal === year && monthLocal === month;
    });
    // prepare location groups
    const locations = blockLocations[block] || [];
    const locationDocs = {};
    locations.forEach(loc => locationDocs[loc] = []);
    meterDocs.forEach(doc => {
        if (locationDocs[doc.location]) {
            locationDocs[doc.location].push(doc);
        }
    });
    // sort docs per location by date/time ascending
    const parseDateTime = (doc) => {
        try {
            if (doc.createdAt && typeof doc.createdAt.toDate === 'function') {
                return doc.createdAt.toDate();
            }
        } catch {}
        return new Date(`${doc.date} ${doc.time}`);
    };
    Object.keys(locationDocs).forEach(loc => {
        locationDocs[loc].sort((a,b) => parseDateTime(a) - parseDateTime(b));
    });
    // initialise global grid for this sheet. Structure: { 'dd/mm/yyyy': { 'location': { reading: number|null, docId: string|null } } }
    window.currentSheetGrid = {};
    // build table headers
    const sheetTable = document.getElementById('sheetTable');
    if (!sheetTable) return;
    const thead = sheetTable.querySelector('thead');
    const tbody = sheetTable.querySelector('tbody');
    if (!thead || !tbody) return;
    thead.innerHTML = '';
    tbody.innerHTML = '';
    // Build table headers: each location has three sub‑columns (Meter, Pemakaian, Akumulasi).
    let headerHtml1 = '<tr><th rowspan="2">Tanggal</th>';
    locations.forEach(loc => {
        headerHtml1 += `<th colspan="3">${loc}</th>`;
    });
    // Append row‑level status and petugas columns
    headerHtml1 += '<th rowspan="2">Status</th><th rowspan="2">Petugas</th></tr>';
    let headerHtml2 = '<tr>';
    locations.forEach(() => {
        headerHtml2 += '<th>Meter</th><th>Pemakaian</th><th>Akumulasi</th>';
    });
    headerHtml2 += '</tr>';
    thead.innerHTML = headerHtml1 + headerHtml2;
    // prepare maps for previous readings and accumulations per location
    const prevReadingMap = {};
    const accumMap = {};
    let totalConsumption = 0;
    // generate rows for each day of the month
    for (let d = 1; d <= daysInMonth; d++) {
        const dateObj = new Date(year, month - 1, d);
        const dateStr = dateObj.toLocaleDateString('id-ID');
        const rowGrid = {};
        let rowHtml = `<tr><td>${dateStr}</td>`;
        let rowStatus = 'OK';
        let rowPetugas = '';
        locations.forEach(loc => {
            const docsList = locationDocs[loc];
            let reading = null;
            let readingDoc = null;
            if (docsList && docsList.length > 0) {
                const docsOnDate = docsList.filter(m => m.date === dateStr);
                if (docsOnDate.length > 0) {
                    // pick latest record on that date
                    docsOnDate.sort((a,b) => {
                        const t1 = parseDateTime(a);
                        const t2 = parseDateTime(b);
                        return t2 - t1;
                    });
                    readingDoc = docsOnDate[0];
                    const rVal = parseFloat(readingDoc.meterReading);
                    reading = Number.isFinite(rVal) ? rVal : null;
                }
            }
            // compute actual using previous reading
            let actual = null;
            if (reading !== null) {
                const prev = prevReadingMap[loc];
                if (prev !== undefined && prev !== null) {
                    const diff = reading - prev;
                    actual = Number.isFinite(diff) ? parseFloat(diff.toFixed(2)) : null;
                    if (actual !== null) {
                        totalConsumption += actual;
                    }
                }
                prevReadingMap[loc] = reading;
            } else {
                rowStatus = 'Pending';
            }
            // update accumulation map
            if (actual !== null) {
                accumMap[loc] = (accumMap[loc] || 0) + actual;
            }
            // store to grid with additional metadata
            rowGrid[loc] = {
                reading: reading,
                docId: readingDoc ? readingDoc.id : null,
                petugas: readingDoc ? (readingDoc.name || readingDoc.userName || '') : ''
            };
            // assign petugas for row if not already chosen
            if (!rowPetugas && rowGrid[loc].petugas) {
                rowPetugas = rowGrid[loc].petugas;
            }
            // build input cell for meter reading
            const inputVal = reading !== null ? reading : '';
            rowHtml += `<td><input type="number" data-date="${dateStr}" data-location="${loc}" value="${inputVal}" step="any" style="width:80px;font-size:12px;border:none;background:transparent;color:inherit;"></td>`;
            // build actual cell
            rowHtml += `<td class="actual-cell" data-date="${dateStr}" data-location="${loc}">${actual !== null ? actual.toFixed(2) : '-'}</td>`;
            // build accumulation cell (show running total if available, otherwise dash)
            const accumVal = actual !== null ? accumMap[loc] : accumMap[loc];
            const accumDisplay = (accumVal !== undefined && accumVal !== null) ? accumVal.toFixed(2) : '-';
            rowHtml += `<td class="accum-cell" data-date="${dateStr}" data-location="${loc}">${accumDisplay}</td>`;
        });
        if (!rowPetugas) {
            rowPetugas = currentUserName || '';
        }
        rowHtml += `<td class="status-cell" data-date="${dateStr}">${rowStatus}</td>`;
        rowHtml += `<td class="petugas-cell" data-date="${dateStr}">${rowPetugas || '-'}</td>`;
        rowHtml += '</tr>';
        tbody.innerHTML += rowHtml;
        window.currentSheetGrid[dateStr] = rowGrid;
        window.currentSheetGrid[dateStr]._status = rowStatus;
        window.currentSheetGrid[dateStr]._petugas = rowPetugas;
    }
    // update total consumption display element
    const totalDiv = document.getElementById('totalConsumption');
    if (totalDiv) {
        totalDiv.textContent = `Total Konsumsi Bulan Ini: ${totalConsumption.toFixed(2)} m³`;
    }
    // attach listeners to inputs for dynamic updates
    tbody.querySelectorAll('input[type="number"]').forEach(input => {
        input.addEventListener('input', handleSheetInputChange);
    });
}
/**
 * Export the current meter sheet to an Excel file.
 */
function exportSheetToExcel() {
    // build export array from currentSheetGrid if available
    if (!window.currentSheetGrid) {
        showNotification('Data sheet belum tersedia untuk diexport.');
        return;
    }
    const grid = window.currentSheetGrid;
    const block = document.getElementById('sheetBlockSelect')?.value || 'Data';
    const monthValue = document.getElementById('sheetMonthSelect')?.value || 'Bulan';
    const locations = blockLocations[block] || [];
    // header row
    const exportData = [];
    const headerRow = ['Tanggal'];
    // For each location, include Meter, Pemakaian and Akumulasi columns
    locations.forEach(loc => {
        headerRow.push(`${loc} Meter`);
        headerRow.push(`${loc} Pemakaian`);
        headerRow.push(`${loc} Akumulasi`);
    });
    // Append Status and Petugas columns
    headerRow.push('Status');
    headerRow.push('Petugas');
    exportData.push(headerRow);
    // sort dates ascending
    const dateKeys = Object.keys(grid).sort((a,b) => {
        const [da, ma, ya] = a.split('/').map(n => parseInt(n));
        const [db, mb, yb] = b.split('/').map(n => parseInt(n));
        return new Date(ya, ma - 1, da) - new Date(yb, mb - 1, db);
    });
    // compute previous reading and accumulation maps
    const prevMap = {};
    const accumMap = {};
    dateKeys.forEach(dateStr => {
        const rowObj = grid[dateStr];
        const row = [dateStr];
        let rowStatus = 'OK';
        let rowPetugas = '';
        locations.forEach(loc => {
            const cell = rowObj[loc] || { reading: null };
            const reading = cell.reading;
            let actual = null;
            if (reading !== null && reading !== undefined) {
                if (prevMap[loc] !== undefined && prevMap[loc] !== null) {
                    const diff = reading - prevMap[loc];
                    actual = Number.isFinite(diff) ? parseFloat(diff.toFixed(2)) : null;
                    if (actual !== null) {
                        accumMap[loc] = (accumMap[loc] || 0) + actual;
                    }
                }
                prevMap[loc] = reading;
            } else {
                rowStatus = 'Pending';
            }
            // row petugas: take first available
            if (!rowPetugas && cell.petugas) {
                rowPetugas = cell.petugas;
            }
            row.push(reading !== null && reading !== undefined ? reading : '-');
            row.push(actual !== null ? actual.toFixed(2) : '-');
            const accumVal = accumMap[loc];
            row.push(accumVal !== undefined && accumVal !== null ? accumVal.toFixed(2) : '-');
        });
        if (!rowPetugas) {
            rowPetugas = currentUserName || '';
        }
        row.push(rowStatus);
        row.push(rowPetugas || '-');
        exportData.push(row);
    });
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(exportData);
    XLSX.utils.book_append_sheet(wb, ws, 'Sheet');
    const fileName = `Meter_Sheet_${block}_${monthValue}.xlsx`;
    XLSX.writeFile(wb, fileName);
}

/**
 * Handle input changes on the interactive meter sheet. Updates the in-memory grid and recalculates
 * actual usage per location across all dates whenever a reading is modified.
 * @param {Event} event
 */
function handleSheetInputChange(event) {
    const input = event.target;
    const dateStr = input.dataset.date;
    const loc = input.dataset.location;
    if (!window.currentSheetGrid || !window.currentSheetGrid[dateStr] || !window.currentSheetGrid[dateStr][loc]) return;
    // Mark sheet as having unsaved changes
    window.unsavedSheetChanges = true;
    let value = parseFloat(input.value);
    if (!Number.isFinite(value)) value = null;
    // update the grid reading value
    window.currentSheetGrid[dateStr][loc].reading = value;
    // recalculate actual and accumulation values for this location across all dates
    const dates = Object.keys(window.currentSheetGrid).sort((a,b) => {
        const [da, ma, ya] = a.split('/').map(n => parseInt(n));
        const [db, mb, yb] = b.split('/').map(n => parseInt(n));
        return new Date(ya, ma - 1, da) - new Date(yb, mb - 1, db);
    });
    let prev = null;
    let accum = 0;
    dates.forEach(d => {
        const cell = window.currentSheetGrid[d][loc];
        const readingVal = cell && (cell.reading !== undefined ? cell.reading : null);
        let actualVal = null;
        if (readingVal !== null && readingVal !== undefined) {
            if (prev !== null && prev !== undefined) {
                const diff = readingVal - prev;
                actualVal = Number.isFinite(diff) ? parseFloat(diff.toFixed(2)) : null;
                if (actualVal !== null) {
                    accum += actualVal;
                }
            }
            prev = readingVal;
        }
        const actualCell = document.querySelector(`.actual-cell[data-date="${d}"][data-location="${loc}"]`);
        if (actualCell) {
            actualCell.textContent = actualVal !== null ? actualVal.toFixed(2) : '-';
        }
        const accumCell = document.querySelector(`.accum-cell[data-date="${d}"][data-location="${loc}"]`);
        if (accumCell) {
            // show running total if accum > 0 or actualVal is not null; otherwise preserve previous displayed value
            if ((actualVal !== null && !isNaN(accum)) || accum > 0) {
                accumCell.textContent = accum.toFixed(2);
            } else if (accum === 0 && actualVal === null) {
                // if there is no reading yet, clear accumulation display
                accumCell.textContent = '-';
            }
        }
    });
    // update row status and petugas for each date
    dates.forEach(d => {
        const rowObj = window.currentSheetGrid[d];
        let status = 'OK';
        let petugasVal = '';
        Object.keys(rowObj).forEach(l => {
            const cell = rowObj[l];
            if (cell.reading === null || cell.reading === undefined) {
                status = 'Pending';
            }
            if (!petugasVal && cell.petugas) {
                petugasVal = cell.petugas;
            }
        });
        if (!petugasVal) {
            petugasVal = currentUserName || '';
        }
        const statusCell = document.querySelector(`.status-cell[data-date="${d}"]`);
        const petugasCell = document.querySelector(`.petugas-cell[data-date="${d}"]`);
        if (statusCell) {
            statusCell.textContent = status;
        }
        if (petugasCell) {
            petugasCell.textContent = petugasVal || '-';
        }
    });
    // recalculate total consumption across all locations and dates
    let total = 0;
    document.querySelectorAll('.actual-cell').forEach(cell => {
        const val = parseFloat(cell.textContent);
        if (!isNaN(val)) {
            total += val;
        }
    });
    const totalDiv = document.getElementById('totalConsumption');
    if (totalDiv) {
        totalDiv.textContent = `Total Konsumsi Bulan Ini: ${total.toFixed(2)} m³`;
    }
}

/**
 * Persist the current interactive meter sheet to Firestore. For each date/location with a reading
 * value, either updates the existing document (if docId is present) or creates a new document.
 */
async function saveSheetToFirestore() {
    if (!window.currentSheetGrid) {
        showNotification('Tidak ada data untuk disimpan.');
        return;
    }
    const block = document.getElementById('sheetBlockSelect')?.value || '';
    if (!block) {
        showNotification('Pilih blok sebelum menyimpan sheet.');
        return;
    }
    try {
        for (const dateStr of Object.keys(window.currentSheetGrid)) {
            const row = window.currentSheetGrid[dateStr];
            for (const loc of Object.keys(row)) {
                const { reading, docId } = row[loc];
                if (reading === null || reading === undefined) continue;
                // Firestore expects date in dd/mm/yyyy format, already provided
                const parts = dateStr.split('/');
                let docDate = dateStr;
                // build a dummy time for newly created docs
                const timeStr = '00:00:00';
                if (docId) {
                    // update existing document
                    await updateDoc(doc(db, 'meters', docId), {
                        meterReading: reading,
                        block: block,
                        location: loc,
                        // keep original date/time
                        updatedAt: serverTimestamp()
                    });
                } else {
                    // add new document
                    await addDoc(collection(db, 'meters'), {
                        nik: currentNIK || '',
                        name: currentUserName || '',
                        date: docDate,
                        time: timeStr,
                        block: block,
                        location: loc,
                        meterReading: reading,
                        notes: '',
                        createdAt: serverTimestamp()
                    });
                }
            }
        }
        showNotification('Sheet berhasil disimpan!', true);
        // reset unsaved changes flag since data has been persisted
        window.unsavedSheetChanges = false;
        // reload sheet to reflect any updated order of docs
        await loadMeterSheet();
    } catch (error) {
        console.error('Gagal menyimpan sheet:', error);
        showNotification('Gagal menyimpan sheet: ' + error.message);
    }
}
/**
 * Set up PDF import for the meter sheet. Parses the PDF text and stores it in Firestore.
 */
/**
 * Set up export of the meter sheet to PDF. When the export button is clicked, the
 * current sheet table is rendered to a canvas and saved as a PDF file. Requires
 * html2canvas and jsPDF libraries loaded in the page.
 */
function setupPdfExport() {
    const exportBtn = document.getElementById('sheetExportPdfButton');
    if (!exportBtn) return;
    exportBtn.addEventListener('click', async () => {
        // ensure there is sheet data loaded
        if (!window.currentSheetGrid) {
            showNotification('Data sheet belum tersedia untuk diekspor.');
            return;
        }
        const table = document.getElementById('sheetTable');
        if (!table) {
            showNotification('Tidak ada tabel untuk diekspor.');
            return;
        }
        try {
            const canvas = await html2canvas(table, { backgroundColor: null });
            const imgData = canvas.toDataURL('image/png');
            const { jsPDF } = window.jspdf;
            // orientation landscape to better fit wide tables
            const pdf = new jsPDF('l', 'pt', 'a4');
            const pageWidth = pdf.internal.pageSize.getWidth();
            const pageHeight = pdf.internal.pageSize.getHeight();
            // calculate dimensions maintaining aspect ratio
            const imgWidth = pageWidth - 20;
            const imgHeight = canvas.height * (imgWidth / canvas.width);
            pdf.addImage(imgData, 'PNG', 10, 10, imgWidth, imgHeight);
            const block = document.getElementById('sheetBlockSelect')?.value || 'Data';
            const monthValue = document.getElementById('sheetMonthSelect')?.value || 'Bulan';
            const fileName = `Meter_Sheet_${block}_${monthValue}.pdf`;
            pdf.save(fileName);
        } catch (err) {
            console.error('Gagal mengekspor PDF:', err);
            showNotification('Gagal mengekspor PDF: ' + err.message);
        }
    });
}
// Attach events for meter sheet controls after DOM is ready
window.addEventListener('DOMContentLoaded', () => {
    // initialise unsaved changes flag
    window.unsavedSheetChanges = false;
    // Populate the hidden block select and create the visible block tabs
    populateSheetBlockSelect();
    // Set the period picker to the current month on load
    const monthInput = document.getElementById('sheetMonthSelect');
    if (monthInput) {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, '0');
        monthInput.value = `${year}-${month}`;
        // When the period changes, reload the sheet automatically
        monthInput.addEventListener('change', () => {
            loadMeterSheet();
        });
    }
    // Select the first available block by default and rebuild the tabs to mark it active
    const blockSelect = document.getElementById('sheetBlockSelect');
    if (blockSelect && blockSelect.options.length > 0) {
        blockSelect.value = blockSelect.options[0].value;
        if (typeof populateBlockTabs === 'function') {
            populateBlockTabs();
        }
    }
    // Attach save handler; export to PDF is configured in setupPdfExport
    const saveBtn = document.getElementById('sheetSaveButton');
    if (saveBtn) {
        saveBtn.addEventListener('click', saveSheetToFirestore);
    }
    // Set up PDF export for the meter sheet
    setupPdfExport();
    // Load the meter sheet immediately using the default block and month
    loadMeterSheet();
});
// ==================== End Meter Excel-style Sheet Functions ====================

// ==================== Attendance Dashboard ====================
// Saat dokumen dimuat, inisialisasi dashboard kehadiran.  Data tersimpan
// menggunakan localStorage sehingga jumlah telat dan pulang cepat tetap
// tersimpan antar sesi.  Fungsi updateAttendanceSummary menghitung total
// keterlambatan dan pulang cepat serta menampilkan peringatan jika total
// mencapai atau melebihi 5 kali.  Referensi desain dashboard berasal dari
// praktik terbaik yang menekankan tampilan ringkas dengan angka tebal dan
// penyampaian informasi yang relevan secara instan【622564324081978†L168-L195】.
// The localStorage-based attendance dashboard has been replaced by a
// Firestore-backed implementation.  See initAttendanceDoc() and
// updateAttendanceUI() for the new logic.  We leave this empty
// handler here to avoid executing the old code on DOMContentLoaded.
document.addEventListener('DOMContentLoaded', () => {
    // No-op for legacy attendance implementation
});
// ==================== End Attendance Dashboard ====================
</script>
</body>
</html>
